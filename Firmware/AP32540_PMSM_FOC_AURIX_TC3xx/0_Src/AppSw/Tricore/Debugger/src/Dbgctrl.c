/*
 * \file Dbgctrl.c
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *                            IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or 
 * the company in which ordinary course of business you are acting and (ii) 
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by 
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the 
 * Software, and to permit third-parties to whom the Software is furnished to 
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */



/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "DbgCtrl.h"
#include "PmsmFoc_Interface.h"
#if(DBGCTRLMODE == ENABLED)

/******************************************************************************/
/*------------------------------Global variables------------------------------*/
/*******************************************************************************/

/******************************************************************************/
/*-------------------------Private Variables/Constants------------------------*/
/******************************************************************************/

static void DbgCtrl_StopSel(void);
static void DbgCtrl_StartSel(void);
static void DbgCtrl_SpeedSel(float32 targetspeed_arg);
static void DbgCtrl_DemoSel(void);
static void DbgCtrl_CalibrateSel(void);
static DBG_SPEEDSEL DbgCtrl_cmd_chk(DBG_SPEEDSEL eDbgCtrl_mode_sel_arg);

/******************************************************************************/
/*--------------------------Function Implementations--------------------------*/
/******************************************************************************/

/* this functionis called  at periodicDebuggerTask */
void DbgCtrl_periodic(st_DbgCtrl *dbgctrl_arg)
{
    dbgctrl_arg->DbgCtrl_current_speed = PmsmFoc_SpeedControl_getRefSpeed(&g_motorControl.pmsmFoc.speedControl);
    dbgctrl_arg->eDbgCtrl_mode_pending = DbgCtrl_cmd_chk(dbgctrl_arg->eDbgCtrl_mode_usrsel);
    if (dbgctrl_arg->eDbgCtrl_mode_pending == DBG_NONE)
    {
        switch (dbgctrl_arg->eDbgCtrl_mode_usrsel)
        {
/* 0 */ case DBG_READY:     
            break;
/* 1 */ case DBG_STOP:      
            DbgCtrl_StopSel();
            dbgctrl_arg->eDbgCtrl_mode_current = DBG_STOP;
            dbgctrl_arg->eDbgCtrl_mode_usrsel = DBG_READY;
            break;
/* 2 */ case DBG_START:
            DbgCtrl_StartSel();
            dbgctrl_arg->eDbgCtrl_mode_current = DBG_START;
            dbgctrl_arg->eDbgCtrl_mode_usrsel = DBG_READY;
            break;
/* 3 */ case DBG_CAL:
            DbgCtrl_CalibrateSel();
            dbgctrl_arg->eDbgCtrl_mode_current = DBG_CAL;
            dbgctrl_arg->eDbgCtrl_mode_usrsel = DBG_READY;  
            break;
/* 4 */ case DBG_SPEEDUP:
            DbgCtrl_SpeedSel(dbgctrl_arg->DbgCtrl_target_speed);
            dbgctrl_arg->eDbgCtrl_mode_current = DBG_SPEEDUP;
            break;
/* 5 */ case DBG_SPEEDZERO: 
            DbgCtrl_SpeedSel(0);
            dbgctrl_arg->eDbgCtrl_mode_current = DBG_SPEEDZERO;
            dbgctrl_arg->eDbgCtrl_mode_usrsel = DBG_READY;
            break;
/* 6 */ case DBG_DEMO:      
            DbgCtrl_DemoSel();
            dbgctrl_arg->eDbgCtrl_mode_current = DBG_DEMO;
            dbgctrl_arg->eDbgCtrl_mode_usrsel = DBG_READY;
            break;
        default:
            dbgctrl_arg->eDbgCtrl_mode_usrsel = DBG_READY;
            break;
        }
    }
    else
    {
        /* code */
        dbgctrl_arg->eDbgCtrl_mode_usrsel = dbgctrl_arg->eDbgCtrl_mode_pending;
    }
}

void DbgCtrl_init(st_DbgCtrl *dbgctrl_arg)
{
    /* Indicate the user select mode */
    dbgctrl_arg->eDbgCtrl_display_case[0] = D1_STOP;
    dbgctrl_arg->eDbgCtrl_display_case[1] = D2_START;
    dbgctrl_arg->eDbgCtrl_display_case[2] = D3_CAL;
    dbgctrl_arg->eDbgCtrl_display_case[3] = D4_SPEEDUP;
    dbgctrl_arg->eDbgCtrl_display_case[4] = D5_SPEEDZERO;
    dbgctrl_arg->eDbgCtrl_display_case[5] = D6_DEMO;

    dbgctrl_arg->eDbgCtrl_mode_usrsel  = DBG_READY;
    dbgctrl_arg->eDbgCtrl_mode_current = DBG_READY;
    dbgctrl_arg->eDbgCtrl_mode_pending = DBG_NONE;
    dbgctrl_arg->DbgCtrl_target_speed  = 1000;
}

static void DbgCtrl_CalibrateSel(void)
{
    PmsmFoc_Interface_stopMotor(&g_motorControl);
    if(g_motorControl.controlParameters.state == StateMachine_motorStop)
    {
        PmsmFoc_PhaseCurrentSense_resetCalibrationStatus(&g_motorControl.inverter.phaseCurrentSense);
        PmsmFoc_resetEncoderCalibrationStatus(&g_motorControl);
        PmsmFoc_PositionAcquisition_init(&g_motorControl.positionSensor, PositionAcquisition_SensorType_Encoder);
        PmsmFoc_Interface_startMotor(&g_motorControl);
    }
}

static void DbgCtrl_StartSel(void)
{
    PmsmFoc_Interface_startMotor(&g_motorControl);
}

static void DbgCtrl_StopSel(void)
{
    float32 refSpeed;
    refSpeed = PmsmFoc_SpeedControl_getRefSpeed(&g_motorControl.pmsmFoc.speedControl);
    // if(refSpeed > 0.0f)
    PmsmFoc_Interface_stopMotor(&g_motorControl);
}

static void DbgCtrl_SpeedSel(float32 targetspeed_arg)
{
    if(g_motorControl.controlParameters.state != StateMachine_focClosedLoop)
    {
        if((g_motorControl.inverter.phaseCurrentSense.calibration.status == PmsmFoc_SensorAdc_CalibrationStatus_done) &
				(g_motorControl.positionSensor.encoder.calibrationStatus == Encoder_CalibrationStatus_done))
                {
                    PmsmFoc_Interface_startMotor(&g_motorControl);
                }
    }

    PmsmFoc_Interface_setMotorTargetSpeed(&g_motorControl, targetspeed_arg);
}

static void DbgCtrl_DemoSel(void)
{
    PmsmFoc_Interface_setDemo(&g_motorControl);
}

static DBG_SPEEDSEL DbgCtrl_cmd_chk(DBG_SPEEDSEL eDbgCtrl_mode_sel_arg)
{
    float32 refSpeed;
    DBG_SPEEDSEL pending_mode;
    pending_mode = DBG_NONE;
    refSpeed = PmsmFoc_SpeedControl_getRefSpeed(&g_motorControl.pmsmFoc.speedControl);
    if(refSpeed > 0.0f)
    {
        switch (eDbgCtrl_mode_sel_arg)
        {
        case DBG_STOP:
            g_motorControl.CurrnetIfMode = STOP_MODE;
            DbgCtrl_SpeedSel(0);
            pending_mode = eDbgCtrl_mode_sel_arg;
            break;
        case DBG_START:
            g_motorControl.CurrnetIfMode = START_MODE;
            DbgCtrl_SpeedSel(0);
            pending_mode = eDbgCtrl_mode_sel_arg;
            break;
        case DBG_CAL:
            g_motorControl.CurrnetIfMode = CAL_MODE;
            DbgCtrl_SpeedSel(0);
            pending_mode = eDbgCtrl_mode_sel_arg;
            break;
        case DBG_DEMO:
            g_motorControl.CurrnetIfMode = DEMO_MODE;
            DbgCtrl_SpeedSel(0);
            pending_mode = eDbgCtrl_mode_sel_arg;
            break;
        case DBG_READY:
        case DBG_SPEEDUP:
        case DBG_SPEEDZERO:
            pending_mode = DBG_NONE;
            break;
        default:
            break;
        }
    }
    else
    {
        pending_mode = DBG_NONE;
    }
    return pending_mode;
}
#endif /* End of DBGCTRL*/
