/*
 * \file PmsmFoc_Interface.c
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *                            IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */



/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "PmsmFoc_Interface.h"
#include "PmsmFoc_Functions.h"
#include "PmsmFoc_Gatedriver.h"
/******************************************************************************/
/*------------------------------Global variables------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-------------------------Private Variables/Constants------------------------*/
/******************************************************************************/

/******************************************************************************/
/*--------------------------Function Implementations--------------------------*/
/******************************************************************************/

void PmsmFoc_Interface_startMotor(MotorControl* const motorCtrl)
{
	if(motorCtrl->interface.CurrnetIfMode == STOP_MODE)
	{
		/* Check the Calibration state */
		if((motorCtrl->inverter.phaseCurrentSense.calibration.status == PmsmFoc_SensorAdc_CalibrationStatus_done) &
				(motorCtrl->positionSensor.encoder.calibrationStatus == Encoder_CalibrationStatus_done))
		{
			motorCtrl->interface.CurrnetIfMode = RUNNING_MODE;
			motorCtrl->controlParameters.state = StateMachine_focClosedLoop;
			PmsmFoc_SpeedControl_enable(&motorCtrl->pmsmFoc.speedControl);
			PmsmFoc_Interface_setStartTargetSpeed(motorCtrl);
			PmsmFoc_Gatedriver_Enable();
		}
		else
		{
			PmsmFoc_Interface_calMotor(motorCtrl);
		}
	}
}

void PmsmFoc_Interface_calMotor(MotorControl* const motorCtrl)
{
	if(motorCtrl->interface.CurrnetIfMode == STOP_MODE)
	{
		motorCtrl->interface.CurrnetIfMode = CAL_MODE;
		motorCtrl->controlParameters.state = StateMachine_PhaseCalibration;
		PmsmFoc_PhaseCurrentSense_resetCalibrationStatus(&motorCtrl->inverter.phaseCurrentSense);
	#if(POSITION_SENSOR_TYPE == ENCODER)
		PmsmFoc_PositionAcquisition_init(&motorCtrl->positionSensor, PositionAcquisition_SensorType_Encoder);
		/* Reset the encoder calibration status */
		PmsmFoc_resetEncoderCalibrationStatus(motorCtrl);
	#else
		/* For other position sensor */
	#endif
		PmsmFoc_SpeedControl_disable(&motorCtrl->pmsmFoc.speedControl);
		PmsmFoc_Gatedriver_Enable();
	}
}

void PmsmFoc_Interface_stopMotor(MotorControl* motorCtrl)
{
	if((motorCtrl->interface.CurrnetIfMode == RUNNING_MODE)||(motorCtrl->interface.CurrnetIfMode == DEMO_MODE))
	{
		motorCtrl->interface.CurrnetIfMode = STOPPING_MODE;
		motorCtrl->pmsmFoc.modulationIndex.real = 0;
		motorCtrl->pmsmFoc.modulationIndex.imag = 0;
		PmsmFoc_SvmStart(&motorCtrl->inverter, motorCtrl->pmsmFoc.modulationIndex);
		/* For the fast stop response */
		Ifx_RampF32_setSlewRate(&motorCtrl->pmsmFoc.speedRamp,USER_MOTOR_SPEED_RAMP_SLEW_RATE*4,USER_MOTOR_SPEED_RAMP_PERIOD);
		PmsmFoc_Interface_setStopMotorTargetSpeed(motorCtrl);
		#if(POSITION_SENSOR_TYPE == ENCODER)
		/* measSpeed returns the wrong value even motor stopped */
		motorCtrl->positionSensor.encoder.incrEncoder.speedFilterEnabled = 0;
		#endif
	}
	else if(motorCtrl->pmsmFoc.speedControl.measSpeed == 0 && motorCtrl->interface.CurrnetIfMode == STOPPING_MODE)
	{
		motorCtrl->interface.CurrnetIfMode = STOP_MODE;
		motorCtrl->controlParameters.state = StateMachine_motorStop;
		Ifx_RampF32_setSlewRate(&motorCtrl->pmsmFoc.speedRamp,USER_MOTOR_SPEED_RAMP_SLEW_RATE,USER_MOTOR_SPEED_RAMP_PERIOD);
		PmsmFoc_Gatedriver_Disable();
		#if(POSITION_SENSOR_TYPE == ENCODER)
		motorCtrl->positionSensor.encoder.incrEncoder.speedFilterEnabled = 1;
		#endif
	}
}

void PmsmFoc_Interface_setDemo(MotorControl* const motorCtrl)
{
	if(motorCtrl->interface.CurrnetIfMode == STOP_MODE)
	{
		/* Check the Calibration state */
		if((motorCtrl->inverter.phaseCurrentSense.calibration.status == PmsmFoc_SensorAdc_CalibrationStatus_done) &
				(motorCtrl->positionSensor.encoder.calibrationStatus == Encoder_CalibrationStatus_done))
		{
			motorCtrl->interface.CurrnetIfMode = DEMO_MODE;
			motorCtrl->controlParameters.state = StateMachine_demo;
			PmsmFoc_Interface_setMotorTargetSpeed(motorCtrl,demospeed[0][0]);
			PmsmFoc_SpeedControl_enable(&motorCtrl->pmsmFoc.speedControl);
			PmsmFoc_Gatedriver_Enable();
		}
		else
		{
			PmsmFoc_Interface_calMotor(motorCtrl);
		}
	}
}

void PmsmFoc_Interface_brakeMotor(MotorControl* const motorCtrl)
{

}

void PmsmFoc_Interface_vfOpenLoopRampup(MotorControl* const motorCtrl)
{

}

void PmsmFoc_Interface_disableInverter(MotorControl* const motorCtrl)
{

}

void PmsmFoc_Interface_enableInverter(MotorControl* const motorCtrl)
{

}


void PmsmFoc_Interface_geVdcLink(MotorControl* const motorCtrl)
{

}

boolean PmsmFoc_Interface_setMotorTargetSpeed(MotorControl* motorCtrl, float32 motorTargetSpeed)
{	
	float32 maxSpeed = PmsmFoc_SpeedControl_getMaxSpeed(&motorCtrl->pmsmFoc.speedControl);
	float32 minSpeed = PmsmFoc_SpeedControl_getMinSpeed(&motorCtrl->pmsmFoc.speedControl);

	boolean result;
    if ((__absf(motorTargetSpeed)) > (maxSpeed))
    {
        motorCtrl->interface.motorTargetSpeed = maxSpeed;
        result = FALSE;
    }
    else if ((__absf(motorTargetSpeed)) < (minSpeed))
    {
        motorCtrl->interface.motorTargetSpeed = minSpeed;
        result = FALSE;
    }
    else
    {
        motorCtrl->interface.motorTargetSpeed = motorTargetSpeed;
        result = TRUE;
    }
    return result;
}

boolean PmsmFoc_Interface_PlsMotorTargetSpeed(MotorControl* motorCtrl)
{	
	boolean result = FALSE;
	if(motorCtrl->interface.CurrnetIfMode == RUNNING_MODE)
	{
		float32 maxSpeed = PmsmFoc_SpeedControl_getMaxSpeed(&motorCtrl->pmsmFoc.speedControl);
		float32	refSpeed = PmsmFoc_SpeedControl_getRefSpeed(&g_motorControl.pmsmFoc.speedControl);
		float32 motorTargetSpeed;
		motorTargetSpeed = refSpeed +100.0f;

		if ((__absf(motorTargetSpeed)) > (maxSpeed))
		{
			motorCtrl->interface.motorTargetSpeed = maxSpeed;
			result = FALSE;
		}
		else
		{
			motorCtrl->interface.motorTargetSpeed = motorTargetSpeed;
			result = TRUE;
		}
	}
    return result;
}

boolean PmsmFoc_Interface_MnsMotorTargetSpeed(MotorControl* motorCtrl)
{	
	boolean result = FALSE;
	if(motorCtrl->interface.CurrnetIfMode == RUNNING_MODE)
	{
		float32 minSpeed = PmsmFoc_SpeedControl_getMinSpeed(&motorCtrl->pmsmFoc.speedControl);
		float32	refSpeed = PmsmFoc_SpeedControl_getRefSpeed(&g_motorControl.pmsmFoc.speedControl);
		float32 motorTargetSpeed;
		motorTargetSpeed = refSpeed - 100.0f;

		if ((__absf(motorTargetSpeed)) < (minSpeed))
		{
			motorCtrl->interface.motorTargetSpeed = minSpeed;
			result = FALSE;
		}
		else
		{
			motorCtrl->interface.motorTargetSpeed = motorTargetSpeed;
			result = TRUE;
		}
	}
    return result;
}

boolean PmsmFoc_Interface_setStartTargetSpeed(MotorControl* motorCtrl)
{	
	float32 minSpeed = PmsmFoc_SpeedControl_getMinSpeed(&motorCtrl->pmsmFoc.speedControl);
	boolean result;
	motorCtrl->interface.motorTargetSpeed = minSpeed;
	result = TRUE;
    return result;
}

boolean PmsmFoc_Interface_setStopMotorTargetSpeed(MotorControl* motorCtrl)
{
    boolean result;
	motorCtrl->interface.motorTargetSpeed = 0;
	result = TRUE;
    return result;
}
