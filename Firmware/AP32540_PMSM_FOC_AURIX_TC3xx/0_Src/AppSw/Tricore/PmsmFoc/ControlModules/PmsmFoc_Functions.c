/*
 * \file PmsmFoc_Functions.c
 * \brief Field Oriented Control
 * \ingroup pmsm_foc_controlmodules
 * \version disabled
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *                            IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */


/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "SysSe/Math/IFX_Cf32.h"
#include "PmsmFoc_Functions.h"
#include "HW_Init.h"
#include "PmsmFoc_CurrentDcLinkSense.h"
#include "PmsmFoc_Gatedriver.h"
#include "PmsmFoc_Interface.h"
/******************************************************************************/
/*------------------------------Global variables------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-------------------------Private Variables/Constants------------------------*/
/******************************************************************************/

/******************************************************************************/
/*--------------------------Function Implementations--------------------------*/
/******************************************************************************/
float32 demospeedcfg[8][2]= {{4000,500},{6000,2000},{3000,500},{200,1000},{6000,2000},{3000,2000},{5000,300},{2000,500}};
void PmsmFoc_initMotorControl(MOTORCTRL_S* const motorCtrl)
{
	/* Initialize the control variables */
	PmsmFoc_initControlVariables(motorCtrl);

	/* Initialize the peripheral modules */
	PmsmFoc_initHardware(motorCtrl);
#if(POSITION_SENSOR_TYPE == ENCODER)
	/* Reset the encoder calibration status */
	PmsmFoc_resetEncoderCalibrationStatus(motorCtrl);
#else
	/* For other position sensor */
#endif
	/* Reset the current sense calibration status and set initial variable values */
	PmsmFoc_PhaseCurrentSense_resetCalibrationStatus(&motorCtrl->inverter.phaseCurrentSense);

#if(PHASE_CURRENT_RECONSTRUCTION == USER_LOWSIDE_THREE_SHUNT_WITH_HIGHSIDE_MONITORING)
	/* Reset the DC-link current sense calibration status and set initial variable values */
	PmsmFoc_CurrentDCLinkSenseHs_resetCalibrationStatus(&motorCtrl->inverter.highSideCurrentSense);

	/* Set the DC-link current sense gain */
	PmsmFoc_CurrentDCLinkSenseHs_setGain(&motorCtrl->inverter.highSideCurrentSense,
			HighSideCurrentSense_Gain_200VperV);
#endif

#if(DC_LINK_VOLTAGE_MEASUREMENT == ENABLED)
	/* Reset the DC-link voltage sense calibration status and set initial variable values */
	PmsmFoc_DcLinkVoltageSense_resetCalibrationStatus(&motorCtrl->inverter.dcLinkVoltageSense);
#endif

#if(BEMF_MEASUREMENT == ENABLED)
	/* Reset the phase voltage sense calibration status and set initial variable values */
	PmsmFoc_BemfVoltageSense_resetCalibrationStatus(&motorCtrl->inverter.bemfVoltageSense);
#endif
	PmsmFoc_Gatedriver_Enable();
}

/* static */
void PmsmFoc_initControlVariables(MOTORCTRL_S* const motorCtrl)
{

	LookUp_Init();
	g_motorCtrl.interface.CurrnetIfMode = CAL_MODE;
	/* Initialization of speed and current reference ramps */
#if(FOC_CONTROL_SCHEME == SPEED_CONTROL)
	Ifx_RampF32_init(&motorCtrl->pmsmFoc.speedRamp,
			USER_MOTOR_SPEED_RAMP_SLEW_RATE,
			USER_MOTOR_SPEED_RAMP_PERIOD);
#elif(FOC_CONTROL_SCHEME == CURRENT_CONTROL)
	Ifx_RampF32_init(&motorCtrl->pmsmFoc.iqRefExternalRamp,
			USER_MOTOR_CURRENT_Q_RAMP_SLEW_RATE,
			USER_MOTOR_CURRENT_Q_RAMP_PERIOD);
	Ifx_RampF32_init(&motorCtrl->pmsmFoc.idRefExternalRamp,
			USER_MOTOR_CURRENT_D_RAMP_SLEW_RATE,
			USER_MOTOR_CURRENT_D_RAMP_PERIOD);
#endif
	motorCtrl->CtrlParms.initState = INIT_IN_PRGRESS;
	/* Control parameters object initialization */
	motorCtrl->CtrlParms.state = STATE_PhaseCalibration;
	motorCtrl->CtrlParms.alignmentCounter   = 0;
	motorCtrl->CtrlParms.counter            = 0;
	motorCtrl->CtrlParms.inverterStatus     = 0;
	motorCtrl->CtrlParms.nonRealTimeCounter = 0;
	motorCtrl->CtrlParms.rampCounter        = 0;
	motorCtrl->CtrlParms.rotationDir        = 0;
#if(FOC_CONTROL_SCHEME == SPEED_CONTROL)
	motorCtrl->CtrlParms.controlScheme = ControlScheme_speed;
#elif(FOC_CONTROL_SCHEME == CURRENT_CONTROL)
	motorCtrl->CtrlParms.controlScheme = ControlScheme_current;
#endif

	motorCtrl->inverter.status = 0;

	/* Motor parameters object initialization */
	motorCtrl->motor.rs        = USER_MOTOR_RESISTANCE_PER_PHASE;
	motorCtrl->motor.ls        = USER_MOTOR_INDUCTANCE_PER_PHASE;
	motorCtrl->motor.polePairs = USER_MOTOR_POLE_PAIR;

	/* Open loop object initialization */
	motorCtrl->openLoop.amplitude            = 0.0;
	motorCtrl->openLoop.electricalAngleDelta = 0.0;
	motorCtrl->openLoop.electricalAngle      = 0.0;
#if(EMOTOR_LIB == MC_EMOTOR)
	motorCtrl->openLoop.modulationIndex = (CplxStdReal) {0.0, 0.0 };
#endif

	/* Position sensor object initialization */
#if(POSITION_SENSOR_TYPE == ENCODER)
	motorCtrl->positionSensor.sensorType                = PositionAcquisition_SensorType_Encoder;
	motorCtrl->positionSensor.encoder.calibrationStatus = ENC_FIND_INDEX;
#endif
	motorCtrl->democontrol.demospeed = demospeedcfg;
	motorCtrl->democontrol.scenarioCnt = 0;

	/* Initialization of speed regulators */
	PmsmFoc_speedcontrol_init(&motorCtrl->pmsmFoc.speedControl);
	PmsmFoc_speedcontrol_setMaxSpeed(&motorCtrl->pmsmFoc.speedControl,
			USER_MOTOR_SPEED_CONTROL_MAX_RPM);
	PmsmFoc_speedcontrol_setMinSpeed(&motorCtrl->pmsmFoc.speedControl,
			USER_MOTOR_SPEED_CONTROL_MIN_RPM);			
	/* Set the Speed controller kp and ki parameter (for fixed point calculation). */
	PmsmFoc_speedcontrol_setKpKi(&motorCtrl->pmsmFoc.speedControl,
			USER_MOTOR_SPEED_CONTROL_KP,
			USER_MOTOR_SPEED_CONTROL_KI,
			USER_MOTOR_SPEED_CONTROL_PERIOD);
	/* Set the Speed controller limits. */
	PmsmFoc_speedcontrol_setLimit(&motorCtrl->pmsmFoc.speedControl,
			USER_MOTOR_SPEED_CONTROL_MIN,
			USER_MOTOR_SPEED_CONTROL_MAX);

	/* Initialization current regulators */
	Ifx_PicF32_init(&motorCtrl->pmsmFoc.piId);
	Ifx_PicF32_init(&motorCtrl->pmsmFoc.piIq);
	/* Set the PI controller kp and ki parameter (for fixed point calculation). */
	Ifx_PicF32_setKpKi(&motorCtrl->pmsmFoc.piId,
			USER_MOTOR_PI_ID_KP,
			USER_MOTOR_PI_ID_KI,
			USER_MOTOR_PI_ID_CONTROL_PERIOD);
	Ifx_PicF32_setKpKi(&motorCtrl->pmsmFoc.piIq,
			USER_MOTOR_PI_IQ_KP,
			USER_MOTOR_PI_IQ_KI,
			USER_MOTOR_PI_IQ_CONTROL_PERIOD);
	/* Set the PI controller limits. */
	Ifx_PicF32_setLimit(&motorCtrl->pmsmFoc.piId,
			-USER_MOTOR_PI_ID_LIMIT_MAX,
			USER_MOTOR_PI_ID_LIMIT_MAX);
	Ifx_PicF32_setLimit(&motorCtrl->pmsmFoc.piIq,
			-USER_MOTOR_PI_IQ_LIMIT_MAX,
			USER_MOTOR_PI_IQ_LIMIT_MAX);
}

void PmsmFoc_doFieldOrientedControl(MOTORCTRL_S* const motorCtrl)
{
	/* Current reconstruction */
	PmsmFoc_reconstructCurrent(motorCtrl);

	/* Update electrical position and measSpeed*/
	motorCtrl->pmsmFoc.electricalAngle =
			(sint16) PmsmFoc_PositionAcquisition_updatePosition(&motorCtrl->positionSensor);
	motorCtrl->pmsmFoc.speedControl.measSpeed = IfxStdIf_Pos_radsToRpm(
			PmsmFoc_PositionAcquisition_updateSpeed(&motorCtrl->positionSensor));
	/* Clarke Transformation */
	PmsmFoc_doClarkeTransform(&motorCtrl->pmsmFoc);

	/* Park Transformation */
	PmsmFoc_doParkTransform(&motorCtrl->pmsmFoc);

	/* Set Id and Iq reference */
	PmsmFoc_setIdqRef(motorCtrl);

	/* PI Controller #1 -  Iq PI controller of FOC */
	PmsmFoc_doIqControl(&motorCtrl->pmsmFoc);

	/* PI Controller #2 -  Id PI controller of FOC */
	PmsmFoc_doIdControl(&motorCtrl->pmsmFoc);

#if(VOLTAGE_LIMIT == ENABLED)
	/* Recalculate voltage vector magnitude */
	motorCtrl->pmsmFoc.vdqMag = PmsmFoc_getVdqMagnitude(&motorCtrl->pmsmFoc);

	/* Voltage Limit */
	PmsmFoc_doVdqLimit(&motorCtrl->pmsmFoc);
#endif

	/* Inverse Park Transformation */
	PmsmFoc_doInverseParkTransform(&motorCtrl->pmsmFoc);

#if(DQ_DECOUPLING == ENABLED)
	PmsmFoc_doDqDecoupling(&motorCtrl->pmsmFoc);
#endif

	PmsmFoc_SvmStart(&motorCtrl->inverter, motorCtrl->pmsmFoc.modulationIndex);
}

void PmsmFoc_resetEncoderCalibrationStatus(MOTORCTRL_S* const motorCtrl)
{
	motorCtrl->positionSensor.encoder.calibrationStatus   = ENC_FIND_INDEX;
	motorCtrl->positionSensor.encoder.incrEncoder.turn    = 0;
	motorCtrl->openLoop.amplitude                         = USER_MOTOR_ENCODER_CAL_TOP_ZERO_AMPL_MAX;
	motorCtrl->openLoop.electricalAngleDelta              = 1;
	motorCtrl->positionSensor.encoder.encOffsetCalCounter = 0;
}

void PmsmFoc_doEncoderCalibration(MOTORCTRL_S* const motorCtrl)
{
#if(EMOTOR_LIB == MC_EMOTOR)
	CplxStdReal cossin;
#endif
	PmsmFoc_PositionAcquisition_updatePosition(&motorCtrl->positionSensor);

	if(motorCtrl->positionSensor.encoder.calibrationStatus == ENC_FIND_INDEX)
	{
		if(motorCtrl->positionSensor.encoder.incrEncoder.turn == 1)
		{
			motorCtrl->positionSensor.encoder.calibrationStatus = ENC_FIND_OFFSET;
			motorCtrl->openLoop.amplitude               = 0.0;
			motorCtrl->openLoop.electricalAngle         = 0;
			motorCtrl->openLoop.electricalAngleDelta    = 0;
			return;
		}
	#if(EMOTOR_LIB == MC_EMOTOR)
		/* Update electrical angle and calculate modulation IndexY0 */
		motorCtrl->openLoop.electricalAngle += motorCtrl->openLoop.electricalAngleDelta;
		if(motorCtrl->openLoop.electricalAngle > (COSSIN_TABLE_SIZE - 1))
		{
			motorCtrl->openLoop.electricalAngle = 0;
		}
		cossin = LookUp_CosinusSinus(motorCtrl->openLoop.electricalAngle);
	#endif
		motorCtrl->openLoop.modulationIndex.real = cossin.real * motorCtrl->openLoop.amplitude;
		motorCtrl->openLoop.modulationIndex.imag = cossin.imag * motorCtrl->openLoop.amplitude;

		PmsmFoc_SvmStart(&motorCtrl->inverter, motorCtrl->openLoop.modulationIndex);
	}
	else if(motorCtrl->positionSensor.encoder.calibrationStatus == ENC_FIND_OFFSET)
	{
		if(motorCtrl->positionSensor.encoder.encOffsetCalCounter < USER_MOTOR_ENCODER_CAL_OFFSET_COUNTS)
		{
			if(motorCtrl->openLoop.amplitude < USER_MOTOR_ENCODER_CAL_OFFSET_AMPL_MAX)
			{
				motorCtrl->openLoop.amplitude += USER_MOTOR_ENCODER_CAL_OFFSET_AMPL_DELTA;
			}
		}
		else
		{		
			motorCtrl->positionSensor.encoder.incrEncoder.offset =
					-motorCtrl->positionSensor.encoder.incrEncoder.rawPosition;
			motorCtrl->openLoop.amplitude                         = USER_MOTOR_ENCODER_CAL_TOP_ZERO_AMPL_MAX;
			motorCtrl->openLoop.electricalAngleDelta              = 1;
			motorCtrl->positionSensor.encoder.calibrationStatus   = ENC_CAL_DONE;
			motorCtrl->positionSensor.encoder.encOffsetCalCounter = 0;
			motorCtrl->positionSensor.encoder.incrEncoder.turn    = 0;
			motorCtrl->interface.CurrnetIfMode                    = STOP_MODE;
			return;
		}
		#if(EMOTOR_LIB == MC_EMOTOR)
			cossin = LookUp_CosinusSinus(0);
		#endif

			motorCtrl->openLoop.modulationIndex.real = cossin.real * motorCtrl->openLoop.amplitude;
			motorCtrl->openLoop.modulationIndex.imag = cossin.imag * motorCtrl->openLoop.amplitude;

			PmsmFoc_SvmStart(&motorCtrl->inverter, motorCtrl->openLoop.modulationIndex);
			motorCtrl->positionSensor.encoder.encOffsetCalCounter++;
	}
}

/* static */
void PmsmFoc_reconstructCurrent(MOTORCTRL_S* const motorCtrl)
{
	/* Read ADC result of the three shunt current */
	PmsmFoc_PhaseCurrentSense_getRawPhaseCurrentValues(&motorCtrl->inverter.phaseCurrentSense);

	motorCtrl->pmsmFoc.iPhaseMeas.u = motorCtrl->inverter.phaseCurrentSense.curVO1.value;
	motorCtrl->pmsmFoc.iPhaseMeas.v = motorCtrl->inverter.phaseCurrentSense.curVO2.value;
	motorCtrl->pmsmFoc.iPhaseMeas.w = - motorCtrl->pmsmFoc.iPhaseMeas.u - motorCtrl->pmsmFoc.iPhaseMeas.v;
	//motorCtrl->pmsmFoc.iPhaseMeas.w = 1.83*(motorCtrl->inverter.phaseCurrentSense.curVO3.value);
#if(PHASE_CURRENT_RECONSTRUCTION == USER_LOWSIDE_THREE_SHUNT_WITH_HIGHSIDE_MONITORING)
	PmsmFoc_CurrentDCLinkSenseHs_getRawCurrentValue(&motorCtrl->inverter.highSideCurrentSense);
#endif
	//motorCtrl->pmsmFoc.iPhaseMeas.w = 1.83*(motorCtrl->inverter.phaseCurrentSense.curVO3.value)+0.08;
}
/* static */
void PmsmFoc_doClarkeTransform(PMSMFOC_S* const foc)
{
#if(EMOTOR_LIB == MC_EMOTOR)
	foc->iab = Clarke(&foc->iPhaseMeas);
#endif
	/**< @brief real is Alpha value of current space vector variable */
	/**< @brief imag is Beta value of current space vector variable */
}
/* static */
void PmsmFoc_doParkTransform(PMSMFOC_S* const foc)
{
#if(EMOTOR_LIB == MC_EMOTOR)
	foc->CurrentAngleCosSin = LookUp_CosinusSinus(foc->electricalAngle);
#endif
#if(EMOTOR_LIB == MC_EMOTOR)
	foc->idqMeas = Park(&foc->iab, &foc->CurrentAngleCosSin);
#endif
}
/* static */
void PmsmFoc_setIdqRef(MOTORCTRL_S* const motorCtrl)
{
	PMSMFOC_S* foc = &motorCtrl->pmsmFoc;
#if(FOC_CONTROL_SCHEME == SPEED_CONTROL)
	if(motorCtrl->CtrlParms.controlScheme == ControlScheme_speed)
	{
		foc->idqRef.imag = foc->speedControl.piSpeed.uk * USER_MOTOR_IQLIMIT;
		foc->idqRef.real = 0.0;
	}
#elif(FOC_CONTROL_SCHEME == CURRENT_CONTROL)
	if (motorCtrl->CtrlParms.controlScheme == ControlScheme_current)
	{
		CplxStdReal temp;
		temp = PmsmFoc_getCurrentRefLinearRamp(&motorCtrl->pmsmFoc);
		foc->idqRef.imag = temp.imag;
		foc->idqRef.real = temp.real;
	}
#endif
	else
	{
		foc->idqRef.imag = 0;
		foc->idqRef.real = 0;
	}

	foc->idqRef.imag = __saturate_stdreal(foc->idqRef.imag,-USER_MOTOR_IQLIMIT, USER_MOTOR_IQLIMIT);
	foc->idqRef.real = __saturate_stdreal(foc->idqRef.real,-USER_MOTOR_IDLIMIT, USER_MOTOR_IDLIMIT);

#if(MTPA == ENABLED)
#elif(FIELD_WEAKENING == ENABLED)
#elif(MAX_EFFICIENCY == ENABLED)
#else
#endif
}
/* static */
void PmsmFoc_doIqControl(PMSMFOC_S* const foc)
{
	foc->idqError.imag = foc->idqRef.imag - foc->idqMeas.imag;
	Ifx_PicF32_step(&foc->piIq, foc->idqError.imag);
	foc->vdqRef.imag = foc->piIq.uk;
}
/* static */
void PmsmFoc_doIdControl(PMSMFOC_S* const foc)
{
	foc->idqError.real = foc->idqRef.real - foc->idqMeas.real;
	Ifx_PicF32_step(&foc->piId, foc->idqError.real);
	foc->vdqRef.real = foc->piId.uk;
}
/* static */
StdReal PmsmFoc_getVdqMagnitude(PMSMFOC_S* const foc)
{
	StdReal vdqMag;
	vdqMag = sqrt((foc->vdqRef.imag * foc->vdqRef.imag) + (foc->vdqRef.real *foc->vdqRef.real));
	return vdqMag;
}
/* static */
void PmsmFoc_doVdqLimit(PMSMFOC_S* const foc)
{
	StdReal modulationIndexReduction;
	modulationIndexReduction = 0.9 / foc->vdqMag;
	if(modulationIndexReduction < 1.0)
	{
		foc->vdqRef.real = foc->vdqRef.real * modulationIndexReduction;
		foc->vdqRef.imag *= foc->vdqRef.imag * modulationIndexReduction;
		foc->piIq.uk = foc->vdqRef.imag;
		foc->piId.uk = foc->vdqRef.real;
	}
}
/* Not used */
StdReal PmsmFoc_getVdqLimit(PMSMFOC_S* const foc)
{
	return 0;
}
/* static */
void PmsmFoc_doInverseParkTransform(PMSMFOC_S* const foc)
{
#if(EMOTOR_LIB == MC_EMOTOR)
	foc->VoltageAngleCosSin = LookUp_CosinusSinus(foc->electricalAngle);
#endif
#if(EMOTOR_LIB == MC_EMOTOR)
	foc->vabRef = Park_Reverse(&foc->vdqRef, &foc->VoltageAngleCosSin);
	foc->modulationIndex = foc->vabRef;
#endif
}

void PmsmFoc_tuneCurrentRegulator(MOTORCTRL_S* const motorCtrl)
{
	/* Current reconstruction */
	PmsmFoc_reconstructCurrent(motorCtrl);

	/* Clarke Transformation */
	PmsmFoc_doClarkeTransform(&motorCtrl->pmsmFoc);

	/* Park Transformation */
	PmsmFoc_doParkTransform(&motorCtrl->pmsmFoc);

	if(motorCtrl->CtrlParms.tuneCurrentRegs == TRUE)
	{
		motorCtrl->CtrlParms.tuneCurrentRegsCounter++;
		if(motorCtrl->CtrlParms.tuneCurrentRegsCounter >= 10000)
		{
			motorCtrl->CtrlParms.tuneCurrentRegsCounter = 0;
			if(motorCtrl->pmsmFoc.idqRef.real == 0.0)
			{
				motorCtrl->pmsmFoc.idqRef.real = 0.5;
				motorCtrl->pmsmFoc.idqRef.imag = 0.0;
			}
			else
			{
				motorCtrl->pmsmFoc.idqRef.real = 0.0;
				motorCtrl->pmsmFoc.idqRef.imag = 0.0;
			}
		}
	}
	if(motorCtrl->CtrlParms.tuneCurrentRegs == FALSE)
	{
		motorCtrl->pmsmFoc.idqRef.real = 0.0;
		motorCtrl->pmsmFoc.idqRef.imag = 0.0;
		
		motorCtrl->CtrlParms.tuneCurrentRegsCounter = 0;
	}
	/* PI Controller #1 -  Iq PI controller of FOC */
	PmsmFoc_doIqControl(&motorCtrl->pmsmFoc);

	/* PI Controller #2 -  Id PI controller of FOC */
	PmsmFoc_doIdControl(&motorCtrl->pmsmFoc);

	/* Inverse Park Transformation */
	PmsmFoc_doInverseParkTransform(&motorCtrl->pmsmFoc);

#if(DQ_DECOUPLING == ENABLED)
	PmsmFoc_doDqDecoupling(&motorCtrl->pmsmFoc);
#endif

	PmsmFoc_SvmStart(&motorCtrl->inverter, motorCtrl->pmsmFoc.modulationIndex);
}
/* static */
void PmsmFoc_doDqDecoupling(PMSMFOC_S* const foc)
{

}

void PmsmFoc_doVfControl(MOTORCTRL_S* const motorCtrl)
{
	/* Update electrical position and measSpeed*/
	motorCtrl->pmsmFoc.electricalAngle =
			(sint16) PmsmFoc_PositionAcquisition_updatePosition(&motorCtrl->positionSensor);
	motorCtrl->pmsmFoc.speedControl.measSpeed = IfxStdIf_Pos_radsToRpm(
			PmsmFoc_PositionAcquisition_updateSpeed(&motorCtrl->positionSensor));
	if(motorCtrl->interface.CurrnetIfMode == RUNNING_MODE)
	{
	#if(EMOTOR_LIB == MC_EMOTOR)
		CplxStdReal cossin;
	#endif

		/* Current reconstruction */
		PmsmFoc_reconstructCurrent(motorCtrl);
		#if(EMOTOR_LIB == MC_EMOTOR)
		/* Update electrical angle and calculate modulation IndexY0 */
		motorCtrl->openLoop.electricalAngle += motorCtrl->openLoop.electricalAngleDelta;
		if(motorCtrl->openLoop.electricalAngle > (COSSIN_TABLE_SIZE - 1))
		{
			motorCtrl->openLoop.electricalAngle = 0;
		}
		cossin = LookUp_CosinusSinus(motorCtrl->openLoop.electricalAngle);
		#endif
		motorCtrl->openLoop.modulationIndex.real = cossin.real * motorCtrl->openLoop.amplitude;
		motorCtrl->openLoop.modulationIndex.imag = cossin.imag * motorCtrl->openLoop.amplitude;
		PmsmFoc_SvmStart(&motorCtrl->inverter, motorCtrl->openLoop.modulationIndex);
	}
}
#if(FOC_CONTROL_SCHEME == SPEED_CONTROL)
void PmsmFoc_doDemo(MOTORCTRL_S* const motorCtrl)
{
	if(motorCtrl->interface.CurrnetIfMode == DEMO_MODE)
	{
		uint8 *democnt;
		float32 demoslewrate;
		float32 demoTargetSpeed;
		democnt         = &(motorCtrl->democontrol.scenarioCnt);
		demoTargetSpeed = motorCtrl->interface.motorTargetSpeed;
		if((demoTargetSpeed-50)<motorCtrl->pmsmFoc.speedControl.measSpeed && motorCtrl->pmsmFoc.speedControl.measSpeed<(demoTargetSpeed+50))
		{
			if (*democnt<7)
			{
				(*democnt)++;
				PmsmFoc_Interface_setMotorTargetSpeed(motorCtrl,motorCtrl->democontrol.demospeed[*democnt][0]);
				demoslewrate = motorCtrl->democontrol.demospeed[*democnt][1];
				Ifx_RampF32_setSlewRate(&motorCtrl->pmsmFoc.speedRamp,demoslewrate,USER_MOTOR_SPEED_RAMP_PERIOD);
			}
			else
			{
				*democnt = 0;
				PmsmFoc_Interface_stopMotor(motorCtrl);
			}
		}
	}
	PmsmFoc_doFieldOrientedControl(motorCtrl);
}
#endif
/* Not used */
void PmsmFoc_doMiscWorks(MOTORCTRL_S* const motorCtrl)
{

}
