/*
 * \file PmsmFoc_Functions.c
 * \brief Field Oriented Control
 * \ingroup pmsm_foc_controlmodules
 * \version disabled
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *                            IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */


/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "SysSe/Math/IFX_Cf32.h"
#include "PmsmFoc_Functions.h"
#include "HW_Init.h"
#include "PmsmFoc_CurrentDcLinkSense.h"
#include "PmsmFoc_Gatedriver.h"

/******************************************************************************/
/*------------------------------Global variables------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-------------------------Private Variables/Constants------------------------*/
/******************************************************************************/

/******************************************************************************/
/*--------------------------Function Implementations--------------------------*/
/******************************************************************************/

void PmsmFoc_initMotorControl(MOTORCTRL_S* const motorCtrl)
{
	/* Initialize the control variables */
	PmsmFoc_initControlVariables(motorCtrl);

	/* Initialize the peripheral modules */
	PmsmFoc_initHardware(motorCtrl);
#if(POSITION_SENSOR_TYPE == ENCODER)
	/* Reset the encoder calibration status */
	PmsmFoc_resetEncoderCalibrationStatus(motorCtrl);
#else
	/* For other position sensor */
#endif
	/* Reset the current sense calibration status and set initial variable values */
	PmsmFoc_PhaseCurrentSense_resetCalibrationStatus(&motorCtrl->inverter.phaseCurrentSense);

#if(PHASE_CURRENT_RECONSTRUCTION == USER_LOWSIDE_THREE_SHUNT_WITH_HIGHSIDE_MONITORING)
	/* Reset the DC-link current sense calibration status and set initial variable values */
	PmsmFoc_CurrentDCLinkSenseHs_resetCalibrationStatus(&motorCtrl->inverter.highSideCurrentSense);

	/* Set the DC-link current sense gain */
	PmsmFoc_CurrentDCLinkSenseHs_setGain(&motorCtrl->inverter.highSideCurrentSense,
			HighSideCurrentSense_Gain_200VperV);
#endif

#if(DC_LINK_VOLTAGE_MEASUREMENT == ENABLED)
	/* Reset the DC-link voltage sense calibration status and set initial variable values */
	PmsmFoc_DcLinkVoltageSense_resetCalibrationStatus(&motorCtrl->inverter.dcLinkVoltageSense);
#endif

#if(BEMF_MEASUREMENT == ENABLED)
	/* Reset the phase voltage sense calibration status and set initial variable values */
	PmsmFoc_BemfVoltageSense_resetCalibrationStatus(&motorCtrl->inverter.bemfVoltageSense);
#endif
	PmsmFoc_Gatedriver_Enable();
}

/* static */
void PmsmFoc_initControlVariables(MOTORCTRL_S* const motorCtrl)
{

	LookUp_Init();
	g_motorCtrl.interface.CurrnetIfMode = CAL_MODE;
	/* Initialization of speed and current reference ramps */
	Ifx_RampF32_init(&motorCtrl->pmsmFoc.speedRamp,
			USER_MOTOR_SPEED_RAMP_SLEW_RATE,
			USER_MOTOR_SPEED_RAMP_PERIOD);
	Ifx_RampF32_init(&motorCtrl->pmsmFoc.iqRefExternalRamp,
			USER_MOTOR_CURRENT_Q_RAMP_SLEW_RATE,
			USER_MOTOR_CURRENT_Q_RAMP_PERIOD);
	Ifx_RampF32_init(&motorCtrl->pmsmFoc.idRefExternalRamp,
			USER_MOTOR_CURRENT_D_RAMP_SLEW_RATE,
			USER_MOTOR_CURRENT_D_RAMP_PERIOD);
	/* Control parameters object initialization */
	motorCtrl->CtrlParms.state = STATE_PhaseCalibration;
	motorCtrl->CtrlParms.alignmentCounter = 0;
	motorCtrl->CtrlParms.counter = 0;
	motorCtrl->CtrlParms.inverterStatus = 0;
	motorCtrl->CtrlParms.nonRealTimeCounter = 0;
	motorCtrl->CtrlParms.rampCounter = 0;
	motorCtrl->CtrlParms.rotationDir = 0;
#if(FOC_CONTROL_SCHEME == SPEED_CONTROL)
	motorCtrl->CtrlParms.controlScheme = ControlScheme_speed;
#elif(FOC_CONTROL_SCHEME == CURRENT_CONTROL)
	motorCtrl->CtrlParms.controlScheme = ControlScheme_current;
#endif

	motorCtrl->inverter.status = 0;

	/* Motor parameters object initialization */
	motorCtrl->motor.rs = USER_MOTOR_RESISTANCE_PER_PHASE;
	motorCtrl->motor.ls = USER_MOTOR_INDUCTANCE_PER_PHASE;
	motorCtrl->motor.polePairs = USER_MOTOR_POLE_PAIR;

	/* Open loop object initialization */
	motorCtrl->openLoop.amplitude = 0.0;
	motorCtrl->openLoop.electricalAngleDelta = 0.0;
	motorCtrl->openLoop.electricalAngle = 0.0;
#if(EMOTOR_LIB == MC_EMOTOR)
	motorCtrl->openLoop.modulationIndex = (CplxStdReal) {0.0, 0.0 };
#endif

	/* Position sensor object initialization */
#if(POSITION_SENSOR_TYPE == ENCODER)
	motorCtrl->positionSensor.sensorType = PositionAcquisition_SensorType_Encoder;
	motorCtrl->positionSensor.encoder.calibrationStatus = ENC_FIND_INDEX;
#endif
	/* Initialization of speed regulators */
	PmsmFoc_speedcontrol_init(&motorCtrl->pmsmFoc.speedControl);
	PmsmFoc_speedcontrol_setMaxSpeed(&motorCtrl->pmsmFoc.speedControl,
			USER_MOTOR_SPEED_CONTROL_MAX_RPM);
	PmsmFoc_speedcontrol_setMinSpeed(&motorCtrl->pmsmFoc.speedControl,
			USER_MOTOR_SPEED_CONTROL_MIN_RPM);			
	/* Set the PI controller kp and ki parameter (for fixed point calculation). */
	PmsmFoc_speedcontrol_setKpKi(&motorCtrl->pmsmFoc.speedControl,
			USER_MOTOR_SPEED_CONTROL_KP,
			USER_MOTOR_SPEED_CONTROL_KI,
			USER_MOTOR_SPEED_CONTROL_PERIOD);
	/* Set the PI controller limits. */
	PmsmFoc_speedcontrol_setLimit(&motorCtrl->pmsmFoc.speedControl,
			USER_MOTOR_SPEED_CONTROL_MIN,
			USER_MOTOR_SPEED_CONTROL_MAX);

	/* Initialization current regulators */
	Ifx_PicF32_init(&motorCtrl->pmsmFoc.piId);
	Ifx_PicF32_init(&motorCtrl->pmsmFoc.piIq);
	/* Set the PI controller kp and ki parameter (for fixed point calculation). */
	Ifx_PicF32_setKpKi(&motorCtrl->pmsmFoc.piId,
			USER_MOTOR_PI_ID_KP,
			USER_MOTOR_PI_ID_KI,
			USER_MOTOR_PI_ID_CONTROL_PERIOD);
	/* Set the PI controller limits. */
	Ifx_PicF32_setKpKi(&motorCtrl->pmsmFoc.piIq,
			USER_MOTOR_PI_IQ_KP,
			USER_MOTOR_PI_IQ_KI,
			USER_MOTOR_PI_IQ_CONTROL_PERIOD);
	/* Set the PI controller limits. */
	Ifx_PicF32_setLimit(&motorCtrl->pmsmFoc.piId,
			-USER_MOTOR_PI_ID_LIMIT_MAX,
			USER_MOTOR_PI_ID_LIMIT_MAX);
	Ifx_PicF32_setLimit(&motorCtrl->pmsmFoc.piIq,
			-USER_MOTOR_PI_IQ_LIMIT_MAX,
			USER_MOTOR_PI_IQ_LIMIT_MAX);
}

void PmsmFoc_doFieldOrientedControl(MOTORCTRL_S* const motorCtrl)
{
	/* Current reconstruction */
	PmsmFoc_reconstructCurrent(motorCtrl);

	/* Update electrical position and measSpeed*/
	motorCtrl->pmsmFoc.electricalAngle =
			(sint16) PmsmFoc_PositionAcquisition_updatePosition(&motorCtrl->positionSensor);
	motorCtrl->pmsmFoc.speedControl.measSpeed = IfxStdIf_Pos_radsToRpm(
			PmsmFoc_PositionAcquisition_updateSpeed(&motorCtrl->positionSensor));
	/* Clarke Transformation */
	PmsmFoc_doClarkeTransform(&motorCtrl->pmsmFoc);

	/* Park Transformation */
	PmsmFoc_doParkTransform(&motorCtrl->pmsmFoc);

	/* Set Id and Iq reference */
	PmsmFoc_setIdqRef(motorCtrl);

	/* PI Controller #1 -  Iq PI controller of FOC */
	PmsmFoc_doIqControl(&motorCtrl->pmsmFoc);

	/* PI Controller #2 -  Id PI controller of FOC */
	PmsmFoc_doIdControl(&motorCtrl->pmsmFoc);

#if(VOLTAGE_LIMIT == ENABLED)
	/* Recalculate voltage vector magnitude */
	motorCtrl->pmsmFoc.vdqMag = PmsmFoc_getVdqMagnitude(&motorCtrl->pmsmFoc);

	/* Voltage Limit */
	PmsmFoc_doVdqLimit(&motorCtrl->pmsmFoc);
#endif

	/* Inverse Park Transformation */
	PmsmFoc_doInverseParkTransform(&motorCtrl->pmsmFoc);

#if(DQ_DECOUPLING == ENABLED)
	PmsmFoc_doDqDecoupling(&motorCtrl->pmsmFoc);
#endif

	PmsmFoc_SvmStart(&motorCtrl->inverter, motorCtrl->pmsmFoc.modulationIndex);
}

void PmsmFoc_resetEncoderCalibrationStatus(MOTORCTRL_S* const motorCtrl)
{
	motorCtrl->positionSensor.encoder.calibrationStatus   = ENC_FIND_INDEX;
	motorCtrl->positionSensor.encoder.incrEncoder.turn    = 0;
	motorCtrl->openLoop.amplitude                         = USER_MOTOR_ENCODER_CAL_TOP_ZERO_AMPL_MAX;
	motorCtrl->openLoop.electricalAngleDelta              = 1;
	motorCtrl->positionSensor.encoder.encOffsetCalCounter = 0;
	motorCtrl->positionSensor.encoder.encFwdCnt           = 0;
}

#if 1
void PmsmFoc_doEncoderCalibration(MOTORCTRL_S* const motorCtrl)
{
#if(EMOTOR_LIB == MC_EMOTOR)
	CplxStdReal cossin;
#endif
	PmsmFoc_PositionAcquisition_updatePosition(&motorCtrl->positionSensor);

	if(motorCtrl->positionSensor.encoder.calibrationStatus == ENC_FIND_INDEX)
	{
		if(motorCtrl->positionSensor.encoder.incrEncoder.turn == 1 && motorCtrl->positionSensor.encoder.encFwdCnt < USER_MOTOR_ENCODER_CAL_TOP_ZERO_FOWARD_COUNTS)
		{
			motorCtrl->positionSensor.encoder.encFwdCnt++;
		}
		else if(motorCtrl->positionSensor.encoder.incrEncoder.turn == 1 && motorCtrl->positionSensor.encoder.encFwdCnt == USER_MOTOR_ENCODER_CAL_TOP_ZERO_FOWARD_COUNTS)
		{
			motorCtrl->positionSensor.encoder.calibrationStatus = ENC_FIND_OFFSET;
			motorCtrl->openLoop.amplitude               = 0.0;
			motorCtrl->openLoop.electricalAngle         = 0;
			motorCtrl->openLoop.electricalAngleDelta    = 0;
			motorCtrl->positionSensor.encoder.encFwdCnt = 0;
		}
	#if(EMOTOR_LIB == MC_EMOTOR)
		/* Update electrical angle and calculate modulation IndexY0 */
		motorCtrl->openLoop.electricalAngle += motorCtrl->openLoop.electricalAngleDelta;
		if(motorCtrl->openLoop.electricalAngle > (COSSIN_TABLE_SIZE - 1))
		{
			motorCtrl->openLoop.electricalAngle = 0;
		}
		cossin = LookUp_CosinusSinus(motorCtrl->openLoop.electricalAngle);
	#endif
		motorCtrl->openLoop.modulationIndex.real = cossin.real * motorCtrl->openLoop.amplitude;
		motorCtrl->openLoop.modulationIndex.imag = cossin.imag * motorCtrl->openLoop.amplitude;

		PmsmFoc_SvmStart(&motorCtrl->inverter, motorCtrl->openLoop.modulationIndex);
	}
	else if(motorCtrl->positionSensor.encoder.calibrationStatus == ENC_FIND_OFFSET)
	{
		if(motorCtrl->positionSensor.encoder.encOffsetCalCounter < USER_MOTOR_ENCODER_CAL_OFFSET_COUNTS)
		{
			if(motorCtrl->openLoop.amplitude < USER_MOTOR_ENCODER_CAL_OFFSET_AMPL_MAX)
			{
				motorCtrl->openLoop.amplitude += USER_MOTOR_ENCODER_CAL_OFFSET_AMPL_DELTA;
			}
		}
		else
		{		
			uint16 angleback;
			uint16 angleback2;
			uint16 anglefwd;
			angleback = MODULE_GPT120.T3.B.T3;
			if(angleback&0xf000)
			{
				angleback2 = USER_MOTOR_ENCODER_GPT_BACK_TOTALCNT - angleback;
				anglefwd   = USER_MOTOR_ENCODER_GPT_FOWARD_TOTALCNT - angleback2;
				motorCtrl->positionSensor.encoder.incrEncoder.offset = -anglefwd;
				MODULE_GPT120.T3.B.T3 = anglefwd;
				MODULE_GPT120.T3CON.B.T3CHDIR =0;
			}
			else
			{
				motorCtrl->positionSensor.encoder.incrEncoder.offset =
					-motorCtrl->positionSensor.encoder.incrEncoder.rawPosition;
			}
			motorCtrl->openLoop.amplitude                         = 0.0;
			motorCtrl->positionSensor.encoder.encOffsetCalCounter = 0;
			motorCtrl->interface.CurrnetIfMode                    = STOP_MODE;
			motorCtrl->positionSensor.encoder.calibrationStatus   = ENC_CAL_DONE;
		}
		#if(EMOTOR_LIB == MC_EMOTOR)
			cossin = LookUp_CosinusSinus(0);
		#endif

			motorCtrl->openLoop.modulationIndex.real = cossin.real * motorCtrl->openLoop.amplitude;
			motorCtrl->openLoop.modulationIndex.imag = cossin.imag * motorCtrl->openLoop.amplitude;

			PmsmFoc_SvmStart(&motorCtrl->inverter, motorCtrl->openLoop.modulationIndex);
			motorCtrl->positionSensor.encoder.encOffsetCalCounter++;
	}
}
#endif

#if 1
#define TOTAL_SINE_TABLE_ANGLE                 (2*(float)PI)
#define TABLE_SIZE                              1024
/* 0.00613592 */
#define ANGLE_STEP                             (TOTAL_SINE_TABLE_ANGLE/(float)TABLE_SIZE)
#define ONE_BY_ANGLE_STEP                      (1/ANGLE_STEP)
#define FAST_LOOP_TIME_SEC              (float)(1/(float)USER_INVERTER_PWM_FREQ_HZ) /* Always runs in sync with PWM */
#define LOCK_TIME_IN_SEC                (2)   /* Startup - Rotor alignment time */
#define LOCK_COUNT_FOR_LOCK_TIME      (uint32)((float)LOCK_TIME_IN_SEC/(float)FAST_LOOP_TIME_SEC)
#define PI_2                                     (float)1.5707963267948966192313216916398
uint32 startupLockCount = 0;
uint32 lockTimeCount = 1000;
CplxStdReal PmsmFoc_CosinusSinus(float32 const rotor_angle)
{
    CplxStdReal result;
    float32 angle = rotor_angle;
    uint16 IndexY0;
    uint16 IndexY1;
    float32 x0, y0, y1, x_interpol;
    /*
		Since Rad angle is using "float", to get a precise value It needs to do linear interpolation.
		Equation: 
		y = y0 + (y1 - y0)*((x - x0)/(x1 - x0))
	*/

    /* Range check 0 <= Angle < 2*PI */
    if( angle <  0 )
    {
        angle = angle + TOTAL_SINE_TABLE_ANGLE;
    }
	else if( angle >= TOTAL_SINE_TABLE_ANGLE  )
    {
        angle = angle - TOTAL_SINE_TABLE_ANGLE;
    }

    IndexY0 = (uint16)(angle / ANGLE_STEP);
    IndexY1 = IndexY0 + 1;

    if(IndexY1 >= TABLE_SIZE )
    {
        IndexY1 = 0;
    }

    x0 = (IndexY0 * ANGLE_STEP);

	/* x_interpol = (x-x0)/(x1-x0) */
    x_interpol = ((angle - x0) * ONE_BY_ANGLE_STEP);

    y0          = sinCosTable[IndexY0];
    y1          = sinCosTable[IndexY1];
    result.imag = y0 + ((y1 - y0) * x_interpol);

    y0          = cosTable[IndexY0];
    y1          = cosTable[IndexY1];
    result.real = y0 + ((y1 - y0) * x_interpol);
    return result;
}
#if 0
uint8 kkks;
uint8 calmode;
uint8 calmode2;
uint32 angles;
uint32 anglesdelta;
uint32 addicnt;
float amps;
uint8 amps2=0;
CplxStdReal cossin;
uint32 cnttt =0;
void PmsmFoc_doEncoderCalibration(MOTORCTRL_S* const motorCtrl)
{
	float32 Anglerad;
	PMSMFOC_S* foc = &motorCtrl->pmsmFoc;
#if(EMOTOR_LIB == MC_EMOTOR)
#endif
	/* Update electrical position*/
	motorCtrl->pmsmFoc.electricalAngle =
			(sint16) PmsmFoc_PositionAcquisition_updatePosition(&motorCtrl->positionSensor);
	/* Current reconstruction */
	PmsmFoc_reconstructCurrent(motorCtrl);
		foc->idqRef.real = 0.4;
		foc->idqRef.imag = 0.0;
	#if 0
	/* if(startupLockCount<(0.5*lockTimeCount)) */
	{
		
		switch (kkks)
		{
		case 0:
			Anglerad = PI_2;
			break;
		case 1:
			Anglerad = PI;
			break;
		case 2:
			Anglerad = PI_2*3;
			break;
		case 3:
			Anglerad = PI*2;
			break;
		case 4:
			Anglerad = 0;
			break;
		default:
			break;
		}
		
		/* inverse */
		PmsmFoc_doClarkeTransform(foc);
		foc->VoltageAngleCosSin = PmsmFoc_CosinusSinus(Anglerad);
		foc->idqMeas = Park(&foc->iab, &foc->VoltageAngleCosSin);
		/* PI Controller #1 -  Iq PI controller of FOC */
		PmsmFoc_doIqControl(foc);
		/* PI Controller #2 -  Id PI controller of FOC */
		PmsmFoc_doIdControl(foc);
		foc->vabRef = Park_Reverse(&foc->vdqRef, &foc->VoltageAngleCosSin);
		foc->modulationIndex = foc->vabRef;
		startupLockCount++;
			PmsmFoc_SvmStart(&motorCtrl->inverter, motorCtrl->pmsmFoc.modulationIndex);
	}
	#endif
	#if 0
	if(startupLockCount<(0.5*lockTimeCount))
	{
		
		switch (kkks)
		{
		case 0:
			Anglerad = PI_2;
			break;
		case 1:
			Anglerad = PI;
			break;
		case 2:
			Anglerad = PI_2*3;
			break;
		case 3:
			Anglerad = PI*2;
			break;
		case 4:
			Anglerad = 0;
			break;
		default:
			break;
		}
		
		/* inverse */
		PmsmFoc_doClarkeTransform(foc);
		foc->VoltageAngleCosSin = PmsmFoc_CosinusSinus(Anglerad);
		foc->idqMeas = Park(&foc->iab, &foc->VoltageAngleCosSin);
		/* PI Controller #1 -  Iq PI controller of FOC */
		PmsmFoc_doIqControl(foc);
		/* PI Controller #2 -  Id PI controller of FOC */
		PmsmFoc_doIdControl(foc);
			foc->vdqRef.imag =0;
		foc->vdqRef.real =0.5;
		foc->vabRef = Park_Reverse(&foc->vdqRef, &foc->VoltageAngleCosSin);
		foc->modulationIndex = foc->vabRef;
		foc->modulationIndex = foc->VoltageAngleCosSin;
				foc->modulationIndex.imag = foc->VoltageAngleCosSin.imag;
		foc->modulationIndex.real = foc->VoltageAngleCosSin.real;

		startupLockCount++;
			//PmsmFoc_SvmStart(&motorCtrl->inverter, motorCtrl->pmsmFoc.modulationIndex);
	
	cossin = LookUp_CosinusSinus(0);
	motorCtrl->openLoop.modulationIndex.real = cossin.real * 0.1;
	motorCtrl->openLoop.modulationIndex.imag = cossin.imag * 0.1;
	PmsmFoc_SvmStart(&motorCtrl->inverter, motorCtrl->pmsmFoc.modulationIndex);			
	}
	else if(startupLockCount<(lockTimeCount))
	{
		Anglerad = 0;
				/* inverse */
		PmsmFoc_doClarkeTransform(foc);
		foc->VoltageAngleCosSin = PmsmFoc_CosinusSinus(Anglerad);
		foc->idqMeas = Park(&foc->iab, &foc->VoltageAngleCosSin);
		/* PI Controller #1 -  Iq PI controller of FOC */
		PmsmFoc_doIqControl(foc);
		/* PI Controller #2 -  Id PI controller of FOC */
		PmsmFoc_doIdControl(foc);
		foc->vdqRef.imag =0;
		foc->vdqRef.real =0.5;
		foc->vabRef = Park_Reverse(&foc->vdqRef, &foc->VoltageAngleCosSin);
		foc->modulationIndex = foc->vabRef;
		foc->modulationIndex.imag = foc->VoltageAngleCosSin.imag;
		foc->modulationIndex.real = foc->VoltageAngleCosSin.real;

		startupLockCount++;
			//PmsmFoc_SvmStart(&motorCtrl->inverter, motorCtrl->pmsmFoc.modulationIndex);

	cossin = LookUp_CosinusSinus(0);
	motorCtrl->openLoop.modulationIndex.real = cossin.real * 0.1;
	motorCtrl->openLoop.modulationIndex.imag = cossin.imag * 0.1;

	PmsmFoc_SvmStart(&motorCtrl->inverter, motorCtrl->openLoop.modulationIndex);
	}
	#endif 
	#if 1
	//if(calmode ==0)
	if(amps2 ==0)
	{

		if (amps >=0.1)
		{
			cnttt++;
			if (cnttt >50000)
			{

			amps = 0;
			amps2 =1;
			cnttt = 0;
			}
		}
		else
		{
			amps+=0.00025;
		}
			cossin = LookUp_CosinusSinus(angles);
			motorCtrl->openLoop.modulationIndex.real = cossin.real * amps;
			motorCtrl->openLoop.modulationIndex.imag = cossin.imag * amps;

		// 	cossin = LookUp_CosinusSinus(electricAngle);
		// motorCtrl->openLoop.modulationIndex.real = cossin.real * motorCtrl->openLoop.amplitude;
		// motorCtrl->openLoop.modulationIndex.imag = cossin.imag * motorCtrl->openLoop.amplitude;
		//PmsmFoc_SvmStart(&motorCtrl->inverter, motorCtrl->pmsmFoc.modulationIndex);
		PmsmFoc_SvmStart(&motorCtrl->inverter, motorCtrl->openLoop.modulationIndex);

	}
	else if (calmode2 == 0)
	{

			anglesdelta = 1;
		angles = angles +anglesdelta;
		if (angles>1024)
		{
		angles = 0;
		}
		if(g_motorCtrl.positionSensor.encoder.incrEncoder.turn==8)
		{
			angles = 300;
			calmode2 =1;
		}
		
		cossin = LookUp_CosinusSinus(angles);
		motorCtrl->openLoop.modulationIndex.real = cossin.real * 0.05;
		motorCtrl->openLoop.modulationIndex.imag = cossin.imag * 0.05;

	// 	cossin = LookUp_CosinusSinus(electricAngle);
	// motorCtrl->openLoop.modulationIndex.real = cossin.real * motorCtrl->openLoop.amplitude;
	// motorCtrl->openLoop.modulationIndex.imag = cossin.imag * motorCtrl->openLoop.amplitude;
		//PmsmFoc_SvmStart(&motorCtrl->inverter, motorCtrl->pmsmFoc.modulationIndex);
		PmsmFoc_SvmStart(&motorCtrl->inverter, motorCtrl->openLoop.modulationIndex);
	}
	else if (calmode2 ==1&&addicnt<3000 )
	{


	cossin = LookUp_CosinusSinus(0);
	motorCtrl->openLoop.modulationIndex.real = cossin.real * amps;
	motorCtrl->openLoop.modulationIndex.imag = 0;
	if (amps >=0.1)
	{
	addicnt++;
	amps=0.1;
	}
	else
	{
		amps+=0.00025;
	}
	

	PmsmFoc_SvmStart(&motorCtrl->inverter, motorCtrl->openLoop.modulationIndex);
	}
	else if (addicnt==3000)
	{
		amps2=0;
		angles =0;
		addicnt =0;
		calmode2 = 0;
		startupLockCount = 0;
			motorCtrl->positionSensor.encoder.incrEncoder.offset =
					-motorCtrl->positionSensor.encoder.incrEncoder.rawPosition;
			motorCtrl->openLoop.amplitude = 0.0;
			motorCtrl->positionSensor.encoder.encOffsetCal = FALSE;
			motorCtrl->interface.CurrnetIfMode = STOP_MODE;
			motorCtrl->positionSensor.encoder.encOffsetCalCounter = 0;
			motorCtrl->positionSensor.encoder.calibrationStatus = ENC_CAL_DONE;
	}
	#endif
	if(kkks == 8)
	{
		startupLockCount = 0;
			motorCtrl->positionSensor.encoder.incrEncoder.offset =
					-motorCtrl->positionSensor.encoder.incrEncoder.rawPosition;
			motorCtrl->openLoop.amplitude = 0.0;
			motorCtrl->positionSensor.encoder.encOffsetCal = FALSE;
			motorCtrl->interface.CurrnetIfMode = STOP_MODE;
			motorCtrl->positionSensor.encoder.encOffsetCalCounter = 0;
			motorCtrl->positionSensor.encoder.calibrationStatus = ENC_CAL_DONE;
	}
		

}
#endif
#endif
/* static */
void PmsmFoc_reconstructCurrent(MOTORCTRL_S* const motorCtrl)
{
	/* Read ADC result of the three shunt current */
	PmsmFoc_PhaseCurrentSense_getRawPhaseCurrentValues(&motorCtrl->inverter.phaseCurrentSense);

	motorCtrl->pmsmFoc.iPhaseMeas.u = motorCtrl->inverter.phaseCurrentSense.curVO1.value;
	motorCtrl->pmsmFoc.iPhaseMeas.v = motorCtrl->inverter.phaseCurrentSense.curVO2.value;
	motorCtrl->pmsmFoc.iPhaseMeas.w = motorCtrl->inverter.phaseCurrentSense.curVO2.value;
	//motorCtrl->pmsmFoc.iPhaseMeas.w = 1.83*(motorCtrl->inverter.phaseCurrentSense.curVO3.value);
#if(PHASE_CURRENT_RECONSTRUCTION == USER_LOWSIDE_THREE_SHUNT_WITH_HIGHSIDE_MONITORING)
	PmsmFoc_CurrentDCLinkSenseHs_getRawCurrentValue(&motorCtrl->inverter.highSideCurrentSense);
#endif
	//motorCtrl->pmsmFoc.iPhaseMeas.w = 1.83*(motorCtrl->inverter.phaseCurrentSense.curVO3.value)+0.08;
}
/* static */
void PmsmFoc_doClarkeTransform(PMSMFOC_S* const foc)
{
#if(EMOTOR_LIB == MC_EMOTOR)
	foc->iab = Clarke(&foc->iPhaseMeas);
#endif
	/**< @brief real is Alpha value of current space vector variable */
	/**< @brief imag is Beta value of current space vector variable */
}
/* static */
void PmsmFoc_doParkTransform(PMSMFOC_S* const foc)
{
#if(EMOTOR_LIB == MC_EMOTOR)
	foc->CurrentAngleCosSin = LookUp_CosinusSinus(foc->electricalAngle);
#endif
#if(EMOTOR_LIB == MC_EMOTOR)
	foc->idqMeas = Park(&foc->iab, &foc->CurrentAngleCosSin);
#endif
}
/* static */
void PmsmFoc_setIdqRef(MOTORCTRL_S* const motorCtrl)
{
	PMSMFOC_S* foc = &motorCtrl->pmsmFoc;
#if(FOC_CONTROL_SCHEME == SPEED_CONTROL)
	if(motorCtrl->CtrlParms.controlScheme == ControlScheme_speed)
	{
		foc->idqRef.imag = foc->speedControl.piSpeed.uk * USER_MOTOR_IQLIMIT;
		foc->idqRef.real = 0.0;
	}
#elif(FOC_CONTROL_SCHEME == CURRENT_CONTROL)
	if (motorCtrl->CtrlParms.controlScheme == ControlScheme_current)
	{
		CplxStdReal temp;
		temp = PmsmFoc_getCurrentRefLinearRamp(&motorCtrl->pmsmFoc);
		foc->idqRef.imag = temp.imag;
		foc->idqRef.real = temp.real;
	}
#endif
	else
	{
		foc->idqRef.imag = 0;
		foc->idqRef.real = 0;
	}

	foc->idqRef.imag = __saturate_stdreal(foc->idqRef.imag,-USER_MOTOR_IQLIMIT, USER_MOTOR_IQLIMIT);
	foc->idqRef.real = __saturate_stdreal(foc->idqRef.real,-USER_MOTOR_IDLIMIT, USER_MOTOR_IDLIMIT);

#if(MTPA == ENABLED)
#elif(FIELD_WEAKENING == ENABLED)
#elif(MAX_EFFICIENCY == ENABLED)
#else
#endif
}
/* static */
void PmsmFoc_doIqControl(PMSMFOC_S* const foc)
{
	foc->idqError.imag = foc->idqRef.imag - foc->idqMeas.imag;
	Ifx_PicF32_step(&foc->piIq, foc->idqError.imag);
	foc->vdqRef.imag = foc->piIq.uk;
}
/* static */
void PmsmFoc_doIdControl(PMSMFOC_S* const foc)
{
	foc->idqError.real = foc->idqRef.real - foc->idqMeas.real;
	Ifx_PicF32_step(&foc->piId, foc->idqError.real);
	foc->vdqRef.real = foc->piId.uk;
}
/* static */
StdReal PmsmFoc_getVdqMagnitude(PMSMFOC_S* const foc)
{
	StdReal vdqMag;
	vdqMag = sqrt((foc->vdqRef.imag * foc->vdqRef.imag) + (foc->vdqRef.real *foc->vdqRef.real));
	return vdqMag;
}
/* static */
void PmsmFoc_doVdqLimit(PMSMFOC_S* const foc)
{
	StdReal modulationIndexReduction;
	modulationIndexReduction = 0.9 / foc->vdqMag;
	if(modulationIndexReduction < 1.0)
	{
		foc->vdqRef.real = foc->vdqRef.real * modulationIndexReduction;
		foc->vdqRef.imag *= foc->vdqRef.imag * modulationIndexReduction;
		foc->piIq.uk = foc->vdqRef.imag;
		foc->piId.uk = foc->vdqRef.real;
	}
}
/* Not used */
StdReal PmsmFoc_getVdqLimit(PMSMFOC_S* const foc)
{
	return 0;
}
/* static */
void PmsmFoc_doInverseParkTransform(PMSMFOC_S* const foc)
{
#if(EMOTOR_LIB == MC_EMOTOR)
	foc->VoltageAngleCosSin = LookUp_CosinusSinus(foc->electricalAngle);
#endif
#if(EMOTOR_LIB == MC_EMOTOR)
	foc->vabRef = Park_Reverse(&foc->vdqRef, &foc->VoltageAngleCosSin);
	foc->modulationIndex = foc->vabRef;
#endif
}

void PmsmFoc_tuneCurrentRegulator(MOTORCTRL_S* const motorCtrl)
{
	/* Current reconstruction */
	PmsmFoc_reconstructCurrent(motorCtrl);

	/* Clarke Transformation */
	PmsmFoc_doClarkeTransform(&motorCtrl->pmsmFoc);

	/* Park Transformation */
	PmsmFoc_doParkTransform(&motorCtrl->pmsmFoc);

	if(motorCtrl->CtrlParms.tuneCurrentRegs == TRUE)
	{
		motorCtrl->CtrlParms.tuneCurrentRegsCounter++;
		if(motorCtrl->CtrlParms.tuneCurrentRegsCounter >= 10000)
		{
			motorCtrl->CtrlParms.tuneCurrentRegsCounter = 0;
			if(motorCtrl->pmsmFoc.idqRef.real == 0.0)
			{
				motorCtrl->pmsmFoc.idqRef.real = 0.5;
				motorCtrl->pmsmFoc.idqRef.imag = 0.0;
			}
			else
			{
				motorCtrl->pmsmFoc.idqRef.real = 0.0;
				motorCtrl->pmsmFoc.idqRef.imag = 0.0;
			}
		}
	}
	if(motorCtrl->CtrlParms.tuneCurrentRegs == FALSE)
	{
		motorCtrl->pmsmFoc.idqRef.real = 0.0;
		motorCtrl->pmsmFoc.idqRef.imag = 0.0;
		
		motorCtrl->CtrlParms.tuneCurrentRegsCounter = 0;
	}
	/* PI Controller #1 -  Iq PI controller of FOC */
	PmsmFoc_doIqControl(&motorCtrl->pmsmFoc);

	/* PI Controller #2 -  Id PI controller of FOC */
	PmsmFoc_doIdControl(&motorCtrl->pmsmFoc);

	/* Inverse Park Transformation */
	PmsmFoc_doInverseParkTransform(&motorCtrl->pmsmFoc);

#if(DQ_DECOUPLING == ENABLED)
	PmsmFoc_doDqDecoupling(&motorCtrl->pmsmFoc);
#endif

	PmsmFoc_SvmStart(&motorCtrl->inverter, motorCtrl->pmsmFoc.modulationIndex);
}
/* static */
void PmsmFoc_doDqDecoupling(PMSMFOC_S* const foc)
{

}

void PmsmFoc_doVfControl(MOTORCTRL_S* const motorCtrl)
{
#if(EMOTOR_LIB == MC_EMOTOR)
	CplxStdReal cossin;
#endif
	/* Update electrical position and measSpeed*/
	motorCtrl->pmsmFoc.electricalAngle =
			(sint16) PmsmFoc_PositionAcquisition_updatePosition(&motorCtrl->positionSensor);
	motorCtrl->pmsmFoc.speedControl.measSpeed = IfxStdIf_Pos_radsToRpm(
			PmsmFoc_PositionAcquisition_updateSpeed(&motorCtrl->positionSensor));

	/* Current reconstruction */
	PmsmFoc_reconstructCurrent(motorCtrl);
	if(motorCtrl->interface.CurrnetIfMode == RUNNING_MODE)
	{
		PmsmFoc_Gatedriver_Enable();
		/* Update electrical angle and calculate modulation IndexY0 */
#if(EMOTOR_LIB == MC_EMOTOR)
		sint16 electricAngle;
		motorCtrl->openLoop.electricalAngle += motorCtrl->openLoop.electricalAngleDelta;
		electricAngle= (motorCtrl->openLoop.electricalAngle >> 16) & (COSSIN_TABLE_SIZE - 1);
		cossin = LookUp_CosinusSinus(electricAngle);
#endif
		motorCtrl->openLoop.modulationIndex.real = cossin.real * motorCtrl->openLoop.amplitude;
		motorCtrl->openLoop.modulationIndex.imag = cossin.imag * motorCtrl->openLoop.amplitude;
	}
	
	if(motorCtrl->interface.CurrnetIfMode == STOP_MODE)
	{
		motorCtrl->openLoop.electricalAngle = 0;
		motorCtrl->openLoop.electricalAngleDelta = 0;
		motorCtrl->openLoop.amplitude = 0.0;
		motorCtrl->openLoop.modulationIndex.real = 0;
		motorCtrl->openLoop.modulationIndex.imag = 0;
		PmsmFoc_Gatedriver_Disable();
	}

	PmsmFoc_SvmStart(&motorCtrl->inverter, motorCtrl->openLoop.modulationIndex);
}
/* Not used */
void PmsmFoc_doMiscWorks(MOTORCTRL_S* const motorCtrl)
{

}
