/**
 * \file TLF3xx8x.c
 * \brief Source file of TLF3xx8x communication and initialization
 *
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.

 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/
#include "TLE9180.h"
#include "bsp.h"
/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/
static void IfxTLE9180_initBuffer(void);
static uint32 IfxTLE9180_loadStartupConfiguration(void);
/******************************************************************************/
/*------------------------------Global variables------------------------------*/
/******************************************************************************/
#if CPU_WHICH_SERVICE_TLE9180 == 0
    #if defined(__GNUC__)
    #pragma section ".text_cpu0" ax
    #pragma section ".bss_cpu0" awc0
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu0"
    #pragma section farbss  "bss_cpu0"
    #pragma section fardata "data_cpu0"
    #pragma section farrom  "rodata_cpu0"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu0"
    #pragma section DATA ".data_cpu0" ".bss_cpu0" far-absolute RW
    #pragma section CONST ".rodata_cpu0"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu0"
    #pragma ghs section bss= ".bss_cpu0"
    #pragma ghs section data=".data_cpu0"
    #pragma ghs section rodata=".rodata_cpu0"
    #endif
#elif ((CPU_WHICH_SERVICE_TLE9180 == 1) && (CPU_WHICH_SERVICE_TLE9180 < IFXCPU_NUM_MODULES))
    #if defined(__GNUC__)
    #pragma section ".text_cpu1" ax
    #pragma section ".bss_cpu1" awc1
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu1"
    #pragma section farbss  "bss_cpu1"
    #pragma section fardata "data_cpu1"
    #pragma section farrom  "rodata_cpu1"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu1"
    #pragma section DATA ".data_cpu1" ".bss_cpu1" far-absolute RW
    #pragma section CONST ".rodata_cpu1"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu1"
    #pragma ghs section bss= ".bss_cpu1"
    #pragma ghs section data=".data_cpu1"
    #pragma ghs section rodata=".rodata_cpu1"
    #endif
#elif ((CPU_WHICH_SERVICE_TLE9180 == 2) && (CPU_WHICH_SERVICE_TLE9180 < IFXCPU_NUM_MODULES))
    #if defined(__GNUC__)
    #pragma section ".text_cpu2" ax
    #pragma section ".bss_cpu2" awc2
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu2"
    #pragma section farbss  "bss_cpu2"
    #pragma section fardata "data_cpu2"
    #pragma section farrom  "rodata_cpu2"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu2"
    #pragma section DATA ".data_cpu2" ".bss_cpu2" far-absolute RW
    #pragma section CONST ".rodata_cpu2"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu2"
    #pragma ghs section bss= ".bss_cpu2"
    #pragma ghs section data=".data_cpu2"
    #pragma ghs section rodata=".rodata_cpu2"
    #endif
#elif ((CPU_WHICH_SERVICE_TLE9180 == 3) && (CPU_WHICH_SERVICE_TLE9180 < IFXCPU_NUM_MODULES))
	#if defined(__GNUC__)
    #pragma section ".text_cpu3" ax
	#pragma section ".bss_cpu3" awc3
	#endif
	#if defined(__TASKING__)
    #pragma section code    "text_cpu3"
    #pragma section farbss  "bss_cpu3"
    #pragma section fardata "data_cpu3"
    #pragma section farrom  "rodata_cpu3"
	#endif
	#if defined(__DCC__)
    #pragma section CODE ".text_cpu3"
	#pragma section DATA ".data_cpu3" ".bss_cpu3" far-absolute RW
    #pragma section CONST ".rodata_cpu3"
	#endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu3"
    #pragma ghs section bss= ".bss_cpu3"
    #pragma ghs section data=".data_cpu3"
    #pragma ghs section rodata=".rodata_cpu3"
    #endif
#elif ((CPU_WHICH_SERVICE_TLE9180 == 4) && (CPU_WHICH_SERVICE_TLE9180 < IFXCPU_NUM_MODULES))
	#if defined(__GNUC__)
    #pragma section ".text_cpu4" ax
	#pragma section ".bss_cpu4" awc4
	#endif
	#if defined(__TASKING__)
    #pragma section code    "text_cpu4"
    #pragma section farbss  "bss_cpu4"
    #pragma section fardata "data_cpu4"
    #pragma section farrom  "rodata_cpu4"
	#endif
	#if defined(__DCC__)
    #pragma section CODE ".text_cpu4"
	#pragma section DATA ".data_cpu4" ".bss_cpu4" far-absolute RW
    #pragma section CONST ".rodata_cpu4"
	#endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu4"
    #pragma ghs section bss= ".bss_cpu4"
    #pragma ghs section data=".data_cpu4"
    #pragma ghs section rodata=".rodata_cpu4"
    #endif
#elif ((CPU_WHICH_SERVICE_TLE9180 == 5) && (CPU_WHICH_SERVICE_TLE9180 < IFXCPU_NUM_MODULES))
	#if defined(__GNUC__)
    #pragma section ".text_cpu5" ax
	#pragma section ".bss_cpu5" awc5
	#endif
	#if defined(__TASKING__)
    #pragma section code    "text_cpu5"
    #pragma section farbss  "bss_cpu5"
    #pragma section fardata "data_cpu5"
    #pragma section farrom  "rodata_cpu5"
	#endif
	#if defined(__DCC__)
    #pragma section CODE ".text_cpu5"
	#pragma section DATA ".data_cpu5" ".bss_cpu5" far-absolute RW
    #pragma section CONST ".rodata_cpu5"
	#endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu5"
    #pragma ghs section bss= ".bss_cpu5"
    #pragma ghs section data=".data_cpu5"
    #pragma ghs section rodata=".rodata_cpu5"
    #endif
#else
#error "Set CPU_WHICH_SERVICE_TLE9180 to a valid value!"
#endif

App_Qspi_TLE9180_Cpu g_Qspi_TLE9180_Cpu;
IfxTLE9180_Pins Tle9180PinCtrl;
/******************************************************************************/
/*------------------------Private Variables/Constants-------------------------*/
/******************************************************************************/
#if defined(__GNUC__)
    #pragma section // end bss section
    #if CPU_WHICH_SERVICE_TLE9180 == 0
    #pragma section ".rodata_cpu0" ac0
    #endif
    #if ((CPU_WHICH_SERVICE_TLE9180 == 1) && (CPU_WHICH_SERVICE_TLE9180 < IFXCPU_NUM_MODULES))
    #pragma section ".rodata_cpu1" ac1
    #endif
    #if ((CPU_WHICH_SERVICE_TLE9180 == 2) && (CPU_WHICH_SERVICE_TLE9180 < IFXCPU_NUM_MODULES))
    #pragma section ".rodata_cpu2" ac2
    #endif
    #if ((CPU_WHICH_SERVICE_TLE9180 == 3) && (CPU_WHICH_SERVICE_TLE9180 < IFXCPU_NUM_MODULES))
    #pragma section ".rodata_cpu3" ac3
    #endif
    #if ((CPU_WHICH_SERVICE_TLE9180 == 4) && (CPU_WHICH_SERVICE_TLE9180 < IFXCPU_NUM_MODULES))
    #pragma section ".rodata_cpu4" ac4
    #endif
    #if ((CPU_WHICH_SERVICE_TLE9180 == 5) && (CPU_WHICH_SERVICE_TLE9180 < IFXCPU_NUM_MODULES))
    #pragma section ".rodata_cpu5" ac5
    #endif
#endif
/* Pins on Application Kit TC3X7 */
const IfxQspi_SpiMaster_Pins tle9180_qspi_pins = {  &TLE9180_SPI_CLOCK_PIN, IfxPort_OutputMode_pushPull,    /* SCLK */
                                                    &TLE9180_SPI_MOSI_PIN,  IfxPort_OutputMode_pushPull,    /* MTSR */
                                                    &TLE9180_SPI_MISO_PIN,  IfxPort_InputMode_pullDown,     /* MRST */
                                                    IfxPort_PadDriver_cmosAutomotiveSpeed1		            /* pad driver mode */
};

const IfxQspi_SpiMaster_Output tle9180_slsOutput = {&TLE9180_SPI_CS_PIN,
                                                    IfxPort_OutputMode_pushPull,
                                                    IfxPort_PadDriver_cmosAutomotiveSpeed1};

static const IfxTLE9180_SpiTx IfxTLE9180_startupConfig[IFX_TLE9180_SPI_STUP_COMMANDS_SIZE]=
{
    { .B.C=1, .B.ADDRESS= 0x01, .B.DATA= 0x81, .B.CRC= 4},   /**< \brief Config General Configuration 1 */
    { .B.C=1, .B.ADDRESS= 0x02, .B.DATA= 0x0F, .B.CRC= 0},   /**< \brief Config General Configuration 2 */
    { .B.C=1, .B.ADDRESS= 0x06, .B.DATA= 0x70, .B.CRC= 6},   /**< \brief Config VDHP Over & Under voltage Thresholds */
    { .B.C=1, .B.ADDRESS= 0x07, .B.DATA= 0x9A, .B.CRC= 6},   /**< \brief Config VDHP Over & Under voltage Thresholds */
    { .B.C=1, .B.ADDRESS= 0x08, .B.DATA= 0x32, .B.CRC= 1},   /**< \brief Config Charge Pump/High-side Buffer Failure Modes */
    { .B.C=1, .B.ADDRESS= 0x0A, .B.DATA= 0x2A, .B.CRC= 3},   /**< \brief Config Vs & VDHP & VCC Undervoltage Failure Modes */
    { .B.C=1, .B.ADDRESS= 0x0B, .B.DATA= 0x4A, .B.CRC= 3},   /**< \brief Config Vs & VDHP & VCC Overvoltage Failure Modes */
    { .B.C=1, .B.ADDRESS= 0x13, .B.DATA= 0x2A, .B.CRC= 5},   /**< \brief Config Overcurrent Failure Modes */
    { .B.C=1, .B.ADDRESS= 0x00, .B.DATA= 0xAC, .B.CRC= 2},   /**< \brief Config Configuration Signature */
    { .B.C=1, .B.ADDRESS= 0x20, .B.DATA= 0x44, .B.CRC= 3},   /**< \brief Config Current Sense Amplifier 1&2 - Gain 1 */
    { .B.C=1, .B.ADDRESS= 0x21, .B.DATA= 0x44, .B.CRC= 7},   /**< \brief Config Current Sense Amplifier 1&2 - Gain 2 */
    { .B.C=1, .B.ADDRESS= 0x22, .B.DATA= 0x44, .B.CRC= 0},   /**< \brief Config Current Sense Amplifier 3 - Gain 1&2 */
    { .B.C=1, .B.ADDRESS= 0x23, .B.DATA= 0x9F, .B.CRC= 0},   /**< \brief Config Current Sense Amplifier Zero Current Offset */
    { .B.C=1, .B.ADDRESS= 0x23, .B.DATA= 0x9F, .B.CRC= 0}    /**< \brief To read the received frame for the prior command. */
};

static const IfxTLE9180_SpiTx IfxTLE9180_readCommands[IFX_TLE9180_SPI_READ_COMMANDS_SIZE]=
{
    { .B.C=0, .B.ADDRESS= 0x25, .B.DATA= 0x00, .B.CRC= 7},   /**< \brief Read Short Circuit Detection Threshold LS1 */
    { .B.C=0, .B.ADDRESS= 0x26, .B.DATA= 0x00, .B.CRC= 0},   /**< \brief Read Short Circuit Detection Threshold LS2 */
    { .B.C=0, .B.ADDRESS= 0x27, .B.DATA= 0x00, .B.CRC= 4},   /**< \brief Read Short Circuit Detection Threshold LS3 */
    { .B.C=0, .B.ADDRESS= 0x28, .B.DATA= 0x00, .B.CRC= 2},   /**< \brief Read Short Circuit Detection Threshold HS1 */
    { .B.C=0, .B.ADDRESS= 0x29, .B.DATA= 0x00, .B.CRC= 6},   /**< \brief Read Short Circuit Detection Threshold HS2 */
    { .B.C=0, .B.ADDRESS= 0x2A, .B.DATA= 0x00, .B.CRC= 1},   /**< \brief Read Short Circuit Detection Threshold HS3 */
    { .B.C=0, .B.ADDRESS= 0x2B, .B.DATA= 0x00, .B.CRC= 5},   /**< \brief Read Limp Home Activation status */
    { .B.C=0, .B.ADDRESS= 0x2C, .B.DATA= 0x00, .B.CRC= 4},   /**< \brief Read Shift Phase Voltage Feedback and CSA Gain */
    { .B.C=0, .B.ADDRESS= 0x2D, .B.DATA= 0x00, .B.CRC= 0},   /**< \brief Read Passive Rectification Threshold */
    { .B.C=0, .B.ADDRESS= 0x2E, .B.DATA= 0x00, .B.CRC= 7},   /**< \brief Read Active Rectification Threshold */
    { .B.C=0, .B.ADDRESS= 0x2F, .B.DATA= 0x00, .B.CRC= 3},   /**< \brief Read Rectification Filter Time */
    { .B.C=0, .B.ADDRESS= 0x30, .B.DATA= 0x00, .B.CRC= 0},   /**< \brief Read Rectification Accuracy */
    { .B.C=0, .B.ADDRESS= 0x00, .B.DATA= 0x00, .B.CRC= 4},   /**< \brief Read Configuration Signature */
    { .B.C=0, .B.ADDRESS= 0x00, .B.DATA= 0x00, .B.CRC= 4}    /**< \brief To read the received frame for the prior command.*/
};
/*Offset VRO Finetunning */
static const IfxTLE9180_SpiTx IfxTLE9180_ofs_finetunning[2]=
{
    { .B.C=1, .B.ADDRESS= 0x00, .B.DATA= 0xBA, .B.CRC= 2},   /**< \brief Read Short Circuit Detection Threshold LS1 */
    { .B.C=1, .B.ADDRESS= 0x23, .B.DATA= 0x95, .B.CRC= 2}   /**< \brief Read Short Circuit Detection Threshold LS2 */
};
#if 0
uint32 IfxTLE9180_ofs_finetunning[25]=
{
	0xA38005,//max nagative
	0xA39502,
	0xA39604,
	0xA39706,
	0xA39805,
	0xA39907,
	0xA39907,
	0xA39A01,
	0xA39B03,
	0xA39C06,
	0xA39D04,
	0xA39E02,
	0xA39F00,//no
	0xA3A001,//positive
	0xA3A103,
	0xA3A205,
	0xA3A307,
	0xA3A402,
	0xA3A500,
	0xA3A606,
	0xA3A704,
	0xA3A807,
	0xA3A905,
	0xA3AA03,
	0xA3BF05//max positive
}
#endif
static const IfxTLE9180_Pins cfg_Tle9180 =
{
    .inhibit	= TLE9180_INHIBIT_PIN,
    .enable	    = TLE9180_ENABLE_PIN,
    .safeOff	= TLE9180_SAFEOFF_PIN,
    .error		= TLE9180_ERROR_PIN
};

#if defined(__GNUC__)
    #pragma section // end rodata section
#endif

/******************************************************************************/
/*-------------------------Function Prototypes--------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

/** \brief TLE9180 (QSPI) initialization
 *
 * This function initializes Qspix in master mode.
 */
void IfxTLE9180_initSpi(void)
{
    /* disable interrupts */
    boolean interruptState = IfxCpu_disableInterrupts();

    IfxQspi_SpiMaster_Config        spiMasterConfig;

    /* create module config */
    IfxQspi_SpiMaster_initModuleConfig(&spiMasterConfig, TLE9180_SPI_CLOCK_PIN.module);

    /* set the maximum baudrate */
    spiMasterConfig.base.maximumBaudrate = 5000000;

    /* ISR priorities and interrupt target */
    spiMasterConfig.base.txPriority  = INTERRUPT_PRIORITY_QSPI4_TX;
    spiMasterConfig.base.rxPriority  = INTERRUPT_PRIORITY_QSPI4_RX;
    spiMasterConfig.base.erPriority  = INTERRUPT_PRIORITY_QSPI4_ERR;
    if (CPU_WHICH_SERVICE_TLE9180)
    	spiMasterConfig.base.isrProvider = (IfxSrc_Tos)(CPU_WHICH_SERVICE_TLE9180+1);
    else
    	spiMasterConfig.base.isrProvider = (IfxSrc_Tos)CPU_WHICH_SERVICE_TLE9180;

#ifdef TLF_QSPI_USE_DMA
        // DMA configuration
        spiMasterConfig.dma.txDmaChannelId = DMA_CH_TLF_QSPI_TX;
        spiMasterConfig.dma.rxDmaChannelId = DMA_CH_TLF_QSPI_RX;
        spiMasterConfig.dma.useDma = 1;
#endif

    spiMasterConfig.pins = &tle9180_qspi_pins;

    /* initialize module */
    IfxQspi_SpiMaster_initModule(&(g_Qspi_TLE9180_Cpu.drivers.spiMaster), &spiMasterConfig);
    /* set the MRST_input also to the selected pad driver mode if needed */
    IfxPort_setPinPadDriver(spiMasterConfig.pins->mrst->pin.port, spiMasterConfig.pins->mrst->pin.pinIndex, spiMasterConfig.pins->pinDriver);

    IfxQspi_SpiMaster_ChannelConfig spiMasterChannelConfig;

    {
        /* create channel config */
        IfxQspi_SpiMaster_initChannelConfig(&spiMasterChannelConfig, &(g_Qspi_TLE9180_Cpu.drivers.spiMaster));

        /* set the baudrate for this channel */
        spiMasterChannelConfig.base.baudrate = IFX_TLE9180_BAUDRATE;

        /* set the transfer data width */
        spiMasterChannelConfig.base.mode.dataWidth = IFX_TLE9180_DATAWIDTH;

        spiMasterChannelConfig.base.mode.csTrailDelay = SpiIf_SlsoTiming_5;
        spiMasterChannelConfig.base.mode.csInactiveDelay = SpiIf_SlsoTiming_7;
        spiMasterChannelConfig.base.mode.csLeadDelay = SpiIf_SlsoTiming_1;

        spiMasterChannelConfig.base.mode.clockPolarity = SpiIf_ClockPolarity_idleLow;

        spiMasterChannelConfig.base.mode.shiftClock = SpiIf_ShiftClock_shiftTransmitDataOnTrailingEdge;
        spiMasterChannelConfig.channelBasedCs = IfxQspi_SpiMaster_ChannelBasedCs_enabled;
        spiMasterChannelConfig.sls.output.pin    = tle9180_slsOutput.pin;
        spiMasterChannelConfig.sls.output.mode   = tle9180_slsOutput.mode;
        spiMasterChannelConfig.sls.output.driver = tle9180_slsOutput.driver;

        /* initialize channel */
        IfxQspi_SpiMaster_initChannel(&g_Qspi_TLE9180_Cpu.drivers.spiMasterChannel,
            &spiMasterChannelConfig);
    }

    /* init tx buffer area */
    IfxTLE9180_initBuffer();

    /* enable interrupts again */
    IfxCpu_restoreInterrupts(interruptState);
}

/**
 * \brief Initialize the TLE9180 driver/interface.
 *
 * \param handle specifies pointer to the \ref TLE9180 object. Values will be populated by this function
 * \param config specifies pointer to the configuration structure
 *
 * \ingroup mod_tle9180_serial
 */


    #if 0
    uint8 test;
    #endif
boolean IfxTLE9180_init(IfxTLE9180_Pins *tle9180PinCtrl)
{
    /* Initialize time constants for Time functions, see bsp.c */
	initTime();
	boolean result = TRUE;
    Ifx_TickTime time = getDeadLine(TimeConst_1ms);

    tle9180PinCtrl->enable = cfg_Tle9180.enable;
    tle9180PinCtrl->error = cfg_Tle9180.error;
    tle9180PinCtrl->inhibit = cfg_Tle9180.inhibit;
    tle9180PinCtrl->safeOff = cfg_Tle9180.safeOff;

    IfxPort_setPinMode(tle9180PinCtrl->inhibit->port, tle9180PinCtrl->inhibit->pinIndex, IfxPort_Mode_outputPushPullGeneral);
    IfxPort_setPinMode(tle9180PinCtrl->enable->port, tle9180PinCtrl->enable->pinIndex, IfxPort_Mode_outputPushPullGeneral);
    IfxPort_setPinMode(tle9180PinCtrl->safeOff->port, tle9180PinCtrl->safeOff->pinIndex   , IfxPort_Mode_outputPushPullGeneral);
    IfxPort_setPinMode(tle9180PinCtrl->error->port, tle9180PinCtrl->error->pinIndex, IfxPort_Mode_inputNoPullDevice);

    IfxTLE9180_deactivateInhibit(tle9180PinCtrl);
    while(isDeadLine(time) != TRUE);
    time = getDeadLine(TimeConst_1s);
    IfxTLE9180_activateInhibit(tle9180PinCtrl);

    while(isDeadLine(time) != TRUE);	// Wait
    time = getDeadLine(TimeConst_1ms);
    IfxTLE9180_deactivateInhibit(tle9180PinCtrl);

    while(isDeadLine(time) != TRUE);	// Wait
    IfxTLE9180_deactivateSafeOff(tle9180PinCtrl);
    IfxTLE9180_loadStartupConfiguration();

    IfxTLE9180_readRegister();
    
    IfxTLE9180_read_write(IfxTLE9180_ofs_finetunning, 2);

    #if 0
    /* Calibration test */
    uint32 senddat2[2];
    /* Calibration */
    senddat2[0] = 0x80BA02;
    senddat2[1] = 0xA4E001;
    
    IfxTLE9180_read_write(senddat2, 2);

    senddat2[0] = 0x240003;
    IfxTLE9180_read_write(senddat2, 1);
    test = g_Qspi_TLE9180_Cpu.qspiBuffer.spiRxBuffer[1].B.DATA;
    while (test!=0x07)
    {
        IfxTLE9180_read_write(senddat2, 1);
    }
    #endif
    return result;
}

uint32 IfxTLE9180_loadStartupConfiguration(void)
{
    for(int i =0; i<IFX_TLE9180_SPI_STUP_COMMANDS_SIZE; i++)
    {
        g_Qspi_TLE9180_Cpu.qspiBuffer.spiTxBuffer[i].U = IfxTLE9180_startupConfig[i].U;
    }

    while (IfxQspi_SpiMaster_getStatus(&g_Qspi_TLE9180_Cpu.drivers.spiMasterChannel) == SpiIf_Status_busy)  {};

    IfxQspi_SpiMaster_exchange(&g_Qspi_TLE9180_Cpu.drivers.spiMasterChannel, &g_Qspi_TLE9180_Cpu.qspiBuffer.spiTxBuffer[0].U,
        &g_Qspi_TLE9180_Cpu.qspiBuffer.spiRxBuffer[0].U, IFX_TLE9180_SPI_STUP_COMMANDS_SIZE);

    /* we wait until our values are read from Qspi */
    while (IfxQspi_SpiMaster_getStatus(&g_Qspi_TLE9180_Cpu.drivers.spiMasterChannel) == SpiIf_Status_busy)  {};

    return (0);
}
/** \brief API to periodically read TLE9180 registers
 * This API shall be called at periodic task each time, this fetches one register value
 * current register that is fetched is indexed with tle9180->readIndex
 */
uint32 IfxTLE9180_readRegister(void)
{
    IfxTLE9180_initBuffer();
    for(int i =0; i<IFX_TLE9180_SPI_READ_COMMANDS_SIZE; i++)
    {
        g_Qspi_TLE9180_Cpu.qspiBuffer.spiTxBuffer[i].U = IfxTLE9180_readCommands[i].U;
    }

    while (IfxQspi_SpiMaster_getStatus(&g_Qspi_TLE9180_Cpu.drivers.spiMasterChannel) == SpiIf_Status_busy)  {};

    IfxQspi_SpiMaster_exchange(&g_Qspi_TLE9180_Cpu.drivers.spiMasterChannel, &g_Qspi_TLE9180_Cpu.qspiBuffer.spiTxBuffer[0],
        &g_Qspi_TLE9180_Cpu.qspiBuffer.spiRxBuffer[0].U, IFX_TLE9180_SPI_READ_COMMANDS_SIZE);

    /* we wait until our values are read from Qspi */
    while (IfxQspi_SpiMaster_getStatus(&g_Qspi_TLE9180_Cpu.drivers.spiMasterChannel) == SpiIf_Status_busy)  {};
    /*
    Remove the no meaningfull frame.
    The content of the first spiRxBuffer is a response to the last Tx command.
    */
    g_Qspi_TLE9180_Cpu.qspiBuffer.spiRxBuffer[0].U = 0xFFFFFFFF;
    return (0);
}

uint32 IfxTLE9180_read_write(uint32* send_data, uint32 data_num)
{
    IfxTLE9180_initBuffer();
    for(int i =0; i<data_num; i++)
    {
        g_Qspi_TLE9180_Cpu.qspiBuffer.spiTxBuffer[i].U = send_data[i];
    }
    /* Send the same last frame to receive the status */
    g_Qspi_TLE9180_Cpu.qspiBuffer.spiTxBuffer[data_num].U = send_data[data_num-1];

    while (IfxQspi_SpiMaster_getStatus(&g_Qspi_TLE9180_Cpu.drivers.spiMasterChannel) == SpiIf_Status_busy)  {};

    IfxQspi_SpiMaster_exchange(&g_Qspi_TLE9180_Cpu.drivers.spiMasterChannel, &g_Qspi_TLE9180_Cpu.qspiBuffer.spiTxBuffer[0].U,
        &g_Qspi_TLE9180_Cpu.qspiBuffer.spiRxBuffer[0].U, (Ifx_SizeT)data_num+1);

    /* we wait until our values are read from Qspi */
    while (IfxQspi_SpiMaster_getStatus(&g_Qspi_TLE9180_Cpu.drivers.spiMasterChannel) == SpiIf_Status_busy)  {};
    /*
    Remove the no meaningfull frame.
    The content of the first spiRxBuffer is a response to the last Tx command.
    */
    g_Qspi_TLE9180_Cpu.qspiBuffer.spiRxBuffer[0].U = 0xFFFFFFFF;
    return (0);
}

static void IfxTLE9180_initBuffer(void)
{
    for(int i =0; i<IFX_TLE9180_BUFFER_SIZE; i++)
    {
        g_Qspi_TLE9180_Cpu.qspiBuffer.spiTxBuffer[i].U = 0;
        g_Qspi_TLE9180_Cpu.qspiBuffer.spiRxBuffer[i].U = 0;
    }
}
#if defined(__GNUC__)
#pragma section // end text section
#endif
#if defined(__TASKING__)
#pragma section code restore
#pragma section fardata restore
#pragma section farbss restore
#pragma section farrom restore
#endif
#if defined(__DCC__)
#pragma section CODE
#pragma section DATA RW
#pragma section CONST
#endif
#if defined(__ghs__)
#pragma ghs section text=default
#pragma ghs section data=default
#pragma ghs section bss=default
#pragma ghs section rodata=default
#endif
