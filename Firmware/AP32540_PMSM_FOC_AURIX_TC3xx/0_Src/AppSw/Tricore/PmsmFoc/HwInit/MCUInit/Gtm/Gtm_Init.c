/*
 * \file Gtm_Init.c
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *                            IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/
#include "Gtm_Init.h"
#include "IfxGtm_Tom_PwmHl.h"
#include "IfxGtm_Trig.h"
#include MCUCARD_TYPE_PATH
#include INVERTERCARD_TYPE_PATH
/******************************************************************************/
/*-------------------------------Global variables-----------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-------------------------Private Variables/Constants------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-------------------------------Private Functions----------------------------*/
/******************************************************************************/
/**
 * This function will setup the trigger channels for the TOM Module
 * \param initialTrigPoint Trigger point set up initially
 */
void PmsmFoc_Gtm_initTriggerChannel(IfxGtm_Tom tom,
                                    IfxGtm_Tom_Ch triggerChannel,
                                    IfxGtm_Tom_Ch timerChannel,
                                    Ifx_TimerValue initialTrigPoint)
{
    uint16 maskShift= (timerChannel <= 7) ? 0 : 8;
    uint16 triggerChannelMask = 1 << (triggerChannel - maskShift);
    Ifx_GTM_TOM_TGC *ptrTgc= (Ifx_GTM_TOM_TGC *)&MODULE_GTM.TOM[tom].TGC0_GLB_CTRL;

    IfxGtm_Tom_Ch_setSignalLevel(&MODULE_GTM.TOM[tom],
                                 triggerChannel, Ifx_ActiveState_high);
    IfxGtm_Tom_Ch_setCounterValue(&MODULE_GTM.TOM[tom], triggerChannel, 0);

    if (triggerChannel != timerChannel)
    {
        /* FIXME add IfxGtm_Tom_Ch_configurePwmMode() and use it */
        IfxGtm_Tom_Ch_setResetSource(&MODULE_GTM.TOM[tom],
                                     triggerChannel,
                                     IfxGtm_Tom_Ch_ResetEvent_onTrigger);
        IfxGtm_Tom_Ch_setClockSource(&MODULE_GTM.TOM[tom],
                                     triggerChannel,
                                     IfxGtm_Tom_Ch_ClkSrc_cmuFxclk0);
        IfxGtm_Tom_Ch_setTriggerOutput(&MODULE_GTM.TOM[tom],
                                       triggerChannel,
                                       IfxGtm_Tom_Ch_OutputTrigger_forward);
        IfxGtm_Tom_Tgc_enableChannels(ptrTgc, triggerChannelMask, 0, FALSE);
    }

    /* Signal must go out of the GTM */
    IfxGtm_Tom_Tgc_enableChannelsOutput(ptrTgc, triggerChannelMask, 0, FALSE);

    IfxGtm_Tom_Ch_setCompareOneShadow(&MODULE_GTM.TOM[tom], triggerChannel, initialTrigPoint + 1);
}

#if (PHASE_CURRENT_RECONSTRUCTION == \
     USER_LOWSIDE_THREE_SHUNT_WITHOUT_HIGHSIDE_MONITORING) || \
    (PHASE_CURRENT_RECONSTRUCTION == \
     USER_LOWSIDE_THREE_SHUNT_WITH_HIGHSIDE_MONITORING)
IFX_INLINE void PmsmFoc_Gtm_initTrigToEvadcCurSense(void)
{
    IfxGtm_Trig_toEVadc(&MODULE_GTM, IfxGtm_Trig_AdcGroup_0, IfxGtm_Trig_AdcTrig_1,
                        IfxGtm_Trig_AdcTrigSource_tom1,
                        IfxGtm_Trig_AdcTrigChannel_7); /* ADC G0 Triggered by GTM TOM1 CH7 */
    IfxGtm_Trig_toEVadc(&MODULE_GTM, IfxGtm_Trig_AdcGroup_1, IfxGtm_Trig_AdcTrig_1,
                        IfxGtm_Trig_AdcTrigSource_tom1,
                        IfxGtm_Trig_AdcTrigChannel_7); /* ADC G1 Triggered by GTM TOM1 CH7 */
    IfxGtm_Trig_toEVadc(&MODULE_GTM, IfxGtm_Trig_AdcGroup_2, IfxGtm_Trig_AdcTrig_1,
                        IfxGtm_Trig_AdcTrigSource_tom1,
                        IfxGtm_Trig_AdcTrigChannel_7); /* ADC G2 Triggered by GTM TOM1 CH7 */
    IfxGtm_Trig_toEVadc(&MODULE_GTM, IfxGtm_Trig_AdcGroup_3, IfxGtm_Trig_AdcTrig_1,
                        IfxGtm_Trig_AdcTrigSource_tom1,
                        IfxGtm_Trig_AdcTrigChannel_7); /* ADC G3 Triggered by GTM TOM1 CH7 */
}
#elif (PHASE_CURRENT_RECONSTRUCTION == USER_LOWSIDE_TWO_SHUNT_MONITORING)
IFX_INLINE void PmsmFoc_Gtm_initTrigToEvadcCurSense(void)
{
    IfxGtm_Trig_toEVadc(&MODULE_GTM, ADCTRIG_U_GROUP, ADCTRIG_U_LINE,
                        ADCTRIGSOURCE,
                        ADCTRIGCHANNEL); /* ADC G0 Triggered by GTM TOM0 CH15 */
    IfxGtm_Trig_toEVadc(&MODULE_GTM, ADCTRIG_V_GROUP, ADCTRIG_V_LINE,
                        ADCTRIGSOURCE,
                        ADCTRIGCHANNEL); /* ADC G3 Triggered by GTM TOM0 TOM0 */
}
#elif (PHASE_CURRENT_RECONSTRUCTION == USER_LOWSIDE_SINGLE_SHUNT)
IFX_INLINE void PmsmFoc_Gtm_initTrigToEvadcCurSense(void)
{
    IfxGtm_Trig_toEVadc(&MODULE_GTM, IfxGtm_Trig_AdcGroup_0, IfxGtm_Trig_AdcTrig_1,
                        IfxGtm_Trig_AdcTrigSource_tom1,
                        IfxGtm_Trig_AdcTrigChannel_13); /* ADC G0 Triggered by GTM TOM1 CH13 */
    IfxGtm_Trig_toEVadc(&MODULE_GTM, IfxGtm_Trig_AdcGroup_1, IfxGtm_Trig_AdcTrig_1,
                        IfxGtm_Trig_AdcTrigSource_tom1,
                        IfxGtm_Trig_AdcTrigChannel_13); /* ADC G1 Triggered by GTM TOM1 CH13 */
    IfxGtm_Trig_toEVadc(&MODULE_GTM, IfxGtm_Trig_AdcGroup_0, IfxGtm_Trig_AdcTrig_1,
                        IfxGtm_Trig_AdcTrigSource_tom1,
                        IfxGtm_Trig_AdcTrigChannel_14); /* ADC G0 Triggered by GTM TOM1 CH14 */
    IfxGtm_Trig_toEVadc(&MODULE_GTM, IfxGtm_Trig_AdcGroup_1, IfxGtm_Trig_AdcTrig_1,
                        IfxGtm_Trig_AdcTrigSource_tom1,
                        IfxGtm_Trig_AdcTrigChannel_14); /* ADC G1 Triggered by GTM TOM1 CH14 */

    PmsmFoc_Gtm_initTriggerChannel(IfxGtm_Tom_1,
                                   IfxGtm_Tom_Ch_13,
                                   IfxGtm_Tom_Ch_0,
                                   (Ifx_TimerValue)(0.25*(50.0e6/USER_GTM_PWM_FREQ_HZ)));
    PmsmFoc_Gtm_initTriggerChannel(IfxGtm_Tom_1,
                                   IfxGtm_Tom_Ch_14,
                                   IfxGtm_Tom_Ch_0,
                                   (Ifx_TimerValue)(0.75*(50.0e6/USER_GTM_PWM_FREQ_HZ)));
}
#endif

#if ((BEMF_MEASUREMENT == ENABLED) || \
     (DC_LINK_VOLTAGE_MEASUREMENT == ENABLED)) && \
    (PHASE_CURRENT_RECONSTRUCTION == USER_LOWSIDE_SINGLE_SHUNT)
IFX_INLINE void PmsmFoc_Gtm_initTrigToEvadcVoltageSense(void)
{
    IfxGtm_Trig_toEVadc(&MODULE_GTM, IfxGtm_Trig_AdcGroup_1, IfxGtm_Trig_AdcTrig_1,
                        IfxGtm_Trig_AdcTrigSource_tom1,
                        IfxGtm_Trig_AdcTrigChannel_7); /* ADC G1 Triggered by GTM TOM1 CH7 */
    IfxGtm_Trig_toEVadc(&MODULE_GTM, IfxGtm_Trig_AdcGroup_2, IfxGtm_Trig_AdcTrig_1,
                        IfxGtm_Trig_AdcTrigSource_tom1,
                        IfxGtm_Trig_AdcTrigChannel_7); /* ADC G2 Triggered by GTM TOM1 CH7 */
    IfxGtm_Trig_toEVadc(&MODULE_GTM, IfxGtm_Trig_AdcGroup_3, IfxGtm_Trig_AdcTrig_1,
                        IfxGtm_Trig_AdcTrigSource_tom1,
                        IfxGtm_Trig_AdcTrigChannel_7); /* ADC G3 Triggered by GTM TOM1 CH7 */
}
#endif

/******************************************************************************/
/*---------------------------Function Implementations-------------------------*/
/******************************************************************************/
void PmsmFoc_Gtm_initGtm(INVERTER_S * const inverter)
{
    boolean interruptState;
    Ifx_GTM *gtm= &MODULE_GTM;

    interruptState= IfxCpu_disableInterrupts();   /*  disable interrupts */
    /* Enable the GTM Module */
    IfxGtm_enable(gtm);

    IfxGtm_Cmu_setGclkFrequency(gtm, IfxGtm_Cmu_getModuleFrequency(gtm));
    IfxGtm_Cmu_setClkFrequency(gtm, IfxGtm_Cmu_Clk_0,IfxGtm_Cmu_getGclkFrequency(gtm));
    /* Initialize the PWM Channels */
#if(GTM_USED == GTM_ATOM_WITHOUT_DTM_USED)
    PmsmFoc_Gtm_initAtom(inverter);	/* ATOM with DTM */
    inverter->pwm3PhaseOutput.timerFreq= IfxGtm_Tom_Ch_getClockFrequency(inverter->pwm3PhaseOutput.timer.gtm, inverter->pwm3PhaseOutput.timer.tom, inverter->pwm3PhaseOutput.timer.timerChannel);
    IfxGtm_Trig_toEVadc(gtm, IfxGtm_Trig_AdcGroup_0, IfxGtm_Trig_AdcTrig_1, IfxGtm_Trig_AdcTrigSource_atom1, IfxGtm_Trig_AdcTrigChannel_7); //ADC G0 Triggered by GTM TOM1 CH7
    IfxGtm_Trig_toEVadc(gtm, IfxGtm_Trig_AdcGroup_1, IfxGtm_Trig_AdcTrig_1, IfxGtm_Trig_AdcTrigSource_atom1, IfxGtm_Trig_AdcTrigChannel_7);//ADC G1 Triggered by GTM TOM1 CH7
    IfxGtm_Trig_toEVadc(gtm, IfxGtm_Trig_AdcGroup_2, IfxGtm_Trig_AdcTrig_1, IfxGtm_Trig_AdcTrigSource_atom1, IfxGtm_Trig_AdcTrigChannel_7);//ADC G1 Triggered by GTM TOM1 CH7
    IfxGtm_Trig_toEVadc(gtm, IfxGtm_Trig_AdcGroup_3, IfxGtm_Trig_AdcTrig_1, IfxGtm_Trig_AdcTrigSource_atom1, IfxGtm_Trig_AdcTrigChannel_7);//ADC G0 Triggered by GTM TOM1 CH7
#elif(GTM_USED == GTM_TOM_WITHOUT_DTM_USED)
    PmsmFoc_Gtm_initTom(inverter);	/* TOM without DTM, two Channel per phase */
    inverter->pwm3PhaseOutput.timerFreq= IfxGtm_Tom_Ch_getClockFrequency(
        inverter->pwm3PhaseOutput.timer.gtm,
        inverter->pwm3PhaseOutput.timer.tom,
        inverter->pwm3PhaseOutput.timer.timerChannel);
    PmsmFoc_Gtm_initTrigToEvadcCurSense();
    #if ((BEMF_MEASUREMENT == ENABLED) || \
    (DC_LINK_VOLTAGE_MEASUREMENT == ENABLED)) && \
    (PHASE_CURRENT_RECONSTRUCTION == USER_LOWSIDE_SINGLE_SHUNT)
    PmsmFoc_Gtm_initTrigToEvadcVoltageSense();
    #endif
    IfxGtm_Cmu_enableClocks(gtm, IFXGTM_CMU_CLKEN_FXCLK);
#endif
    /* enable interrupts again */
    IfxCpu_restoreInterrupts(interruptState);
}

void PmsmFoc_Gtm_initAtom(INVERTER_S * const inverter)
{
    /* Not used */
}

void PmsmFoc_Gtm_initTom(INVERTER_S * const inverter)
{
    /* GTM TOM configuration */
    IfxGtm_Tom_Timer_Config timerConfig;
    {
        IfxGtm_Tom_Timer_initConfig(&timerConfig, &MODULE_GTM);

        timerConfig.base.frequency                  = USER_INVERTER_PWM_FREQ_HZ / 2;
        timerConfig.base.isrPriority                = 0;
        timerConfig.base.isrProvider                = IfxSrc_Tos_cpu0;
        timerConfig.base.minResolution              = 0.1e-6;                                                      //(1.0 / timerConfig.base.frequency) / 1000;
        timerConfig.base.trigger.enabled            = TRUE;
        timerConfig.base.trigger.outputEnabled      = FALSE;
        #if OUTPUTTEST
        timerConfig.base.trigger.outputEnabled      = TRUE;
        #endif
        timerConfig.base.trigger.risingEdgeAtPeriod = FALSE;
        timerConfig.base.trigger.triggerPoint       = (Ifx_TimerValue)(0.5*(50.0e6 / USER_INVERTER_PWM_FREQ_HZ));
        timerConfig.clock                           = IfxGtm_Tom_Ch_ClkSrc_cmuFxclk0;
        timerConfig.timerChannel                    = REF_CHANNEL;
        timerConfig.tom                             = PWM_MODULE;
        timerConfig.triggerOut                      = ADC_TRIGGER_CHANNEL;
        #if OUTPUTTEST
        timerConfig.refout                          = REF_TESTOUPUT_CHANNEL;
        #endif

        IfxGtm_Tom_Timer_init(&inverter->pwm3PhaseOutput.timer, &timerConfig);
    }
    /* Configuration of the PWM Channels to control High-side and Low-side power-stages */
    {
        IfxGtm_Tom_PwmHl_Config pwmHlConfig;
        IfxGtm_Tom_ToutMapP ccx[]=
            {
            PHASE_U_HS, /**< \brief PWM High-side 1 */
            PHASE_V_HS, /**< \brief PWM High-side 2 */
            PHASE_W_HS  /**< \brief PWM High-side 3 */
            };
        IfxGtm_Tom_ToutMapP coutx[]=
            {
            PHASE_U_LS, /**< \brief PWM Low-side 1 */
            PHASE_V_LS, /**< \brief PWM Low-side 2 */
            PHASE_W_LS  /**< \brief PWM Low-side 3 */
            };
        IfxGtm_Tom_PwmHl_initConfig(&pwmHlConfig);

        pwmHlConfig.base.channelCount= sizeof(ccx)
            / sizeof(IfxGtm_Tom_ToutMapP);
        pwmHlConfig.base.deadtime= 1.0e-6;
        pwmHlConfig.base.minPulse= 1.0e-6;
        pwmHlConfig.base.outputMode= IfxPort_OutputMode_pushPull;
        pwmHlConfig.base.outputDriver= IfxPort_PadDriver_cmosAutomotiveSpeed2;
    #if(TLE9180_DRIVER == ENABLED)
        pwmHlConfig.base.ccxActiveState= Ifx_ActiveState_low;
        pwmHlConfig.base.coutxActiveState= Ifx_ActiveState_high;
    #endif /* End of TLE9180_DRIVER */

        pwmHlConfig.ccx= ccx;
        pwmHlConfig.coutx= coutx;
        pwmHlConfig.timer= &inverter->pwm3PhaseOutput.timer;
        pwmHlConfig.tom= timerConfig.tom;

        IfxGtm_Tom_PwmHl_init(&inverter->pwm3PhaseOutput.pwm, &pwmHlConfig);
        IfxGtm_Tom_PwmHl_setMode(&inverter->pwm3PhaseOutput.pwm,Ifx_Pwm_Mode_centerAligned);
        IfxGtm_Tom_Timer_updateInputFrequency(&inverter->pwm3PhaseOutput.timer);
    }
    IfxGtm_Tom_Timer_run(&inverter->pwm3PhaseOutput.timer);
}

