/**
 * \file mebnu.c
 * \brief Source file for our menu
 *
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.

 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/
#include <Cpu/Std/Ifx_Types.h>
#include <stdio.h>
#include <string.h>
#if GENERAL_TFTKIT
#include "Configuration.h"
#endif
#include "Display_Cfg_AppKitTft_TC387A.h"
#include "conio_tft.h"
#include "touch.h"
#if GENERAL_TFTKIT
//#include "main_appl.h"
#include "RTC.h"
#include "background_light.h"
#include "Measurement.h"
#endif

#include "menue.h"
#include "PmsmFoc_Interface.h"
/******************************************************************************/
/*------------------------Inline Function Prototypes--------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-------------------------Function Prototypes--------------------------------*/
/******************************************************************************/
void Menue_display(sint32 ind, TDISPLAYENTRY * pdisplayentry);
sint32 Menue_input (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void Menue_displayTime(sint32 ind, TDISPLAYENTRY * pdisplayentry);
void Menue_ResetTimeSel(sint32 ind, TDISPLAYENTRY * pdisplayentry);
void Menue_ResetTime(sint32 ind, TDISPLAYENTRY *pdisplayentry);
void Menue_noAction (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void Menue_displaySpeed (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void Menue_displayRSpeed (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void Menue_displayPosition (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void Menue_displayMode (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void Menue_CalibrateSel(sint32 ind, TDISPLAYENTRY * pdisplayentry);
void Menue_DemoSel(sint32 ind, TDISPLAYENTRY * pdisplayentry);
void Menue_SpeedPlsSel(sint32 ind, TDISPLAYENTRY * pdisplayentry);
void Menue_SpeedMnsSel(sint32 ind, TDISPLAYENTRY * pdisplayentry);
void Menue_StartSel(sint32 ind, TDISPLAYENTRY * pdisplayentry);
void Menue_StopSel(sint32 ind, TDISPLAYENTRY * pdisplayentry);

/******************************************************************************/
/*------------------------Private Variables/Constants-------------------------*/
/******************************************************************************/

// *INDENT-OFF*
const TDISPLAYENTRY menulist[] = {
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 22, 0, Menue_display, Menue_display, Menue_input,"PMSM_FOC_AURIX_TC3xx"},        //TFT Main Menue
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 22, 1, Menue_display, Menue_display, Menue_input,"SW V1.0.2, HW V3.2"},        //TFT Main Menue

		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 22, 3, Menue_noAction, Menue_displayTime, Menue_input,"Time Elapsed 00:00:00"},
		{DISP_BRN_WHT, SLCT_RED_BLUE, 29,39, 3, Menue_ResetTimeSel, Menue_ResetTime, Menue_input,"Reset Time"},

		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1,38, 5, Menue_noAction, Menue_display,       Menue_input,{0xDA,0xC4, 'S', 't', 'a', 't', 'u', 's',0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xBF}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 1, 6, Menue_noAction, Menue_display,       Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 2,17, 6, Menue_noAction, Menue_displaySpeed,  Menue_input,"Speed: 0 rpm"},
		{DISP_BLUE_YELW, DISP_BLUE_YELW,21,36, 6, Menue_noAction, Menue_displayPosition, Menue_input,"Position: 0 deg"},
		{DISP_BLUE_YELW, DISP_BLUE_YELW,38,38, 6, Menue_noAction, Menue_display,       Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 1, 7, Menue_noAction, Menue_display,       Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW,38,38, 7, Menue_noAction, Menue_display,       Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 2,17, 8, Menue_noAction, Menue_displayRSpeed, Menue_input,"Ref  : 0 rpm"},
		{DISP_BLUE_YELW, DISP_BLUE_YELW,21,38, 8, Menue_noAction, Menue_displayMode,   Menue_input,"State:"},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 1, 8, Menue_noAction, Menue_display,       Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW,38,38, 8, Menue_noAction, Menue_display,       Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1,38, 9, Menue_noAction, Menue_display,       Menue_input,{0xC0,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xD9}},

		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1,38, 10, Menue_noAction, Menue_display, Menue_input,{0xDA,0xC4, 'C', 'o', 'n', 't', 'r', 'o', 'l',0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xBF}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 1, 11, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW,38,38, 11, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 1, 12, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW,38,38, 12, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 1, 13, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW,38,38, 13, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 1, 14, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW,38,38, 14, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 1, 15, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW,38,38, 15, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 1, 16, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW,38,38, 16, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 1, 17, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW,38,38, 17, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1,38, 18, Menue_noAction, Menue_display, Menue_input,{0xC0,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xD9}},

		{DISP_BRN_WHT, SLCT_RED_BLUE, 3,12,11, Menue_CalibrateSel, Menue_display, Menue_input,{0xDA,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xBF}},
		{DISP_BRN_WHT, SLCT_RED_BLUE, 3, 3,12, Menue_CalibrateSel, Menue_display, Menue_input,{0xB3}},
		{DISP_BRN_WHT, SLCT_RED_BLUE, 4,11,12, Menue_CalibrateSel, Menue_display, Menue_input,"  CAL   "},
		{DISP_BRN_WHT, SLCT_RED_BLUE,12,12,12, Menue_CalibrateSel, Menue_display, Menue_input,{0xB3}},
		{DISP_BRN_WHT, SLCT_RED_BLUE, 3,12,13, Menue_CalibrateSel, Menue_display, Menue_input,{0xC0,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xD9}},

		{DISP_BRN_WHT, SLCT_RED_BLUE, 3,12,15, Menue_DemoSel,      Menue_display, Menue_input,{0xDA,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xBF}},
		{DISP_BRN_WHT, SLCT_RED_BLUE, 3, 3,16, Menue_DemoSel,      Menue_display, Menue_input,{0xB3}},
		{DISP_BRN_WHT, SLCT_RED_BLUE, 4,11,16, Menue_DemoSel,      Menue_display, Menue_input,"  DEMO  "},
		{DISP_BRN_WHT, SLCT_RED_BLUE,12,12,16, Menue_DemoSel,      Menue_display, Menue_input,{0xB3}},
		{DISP_BRN_WHT, SLCT_RED_BLUE, 3,12,17, Menue_DemoSel,      Menue_display, Menue_input,{0xC0,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xD9}},

		{DISP_BRN_WHT, SLCT_RED_BLUE,14,24,11, Menue_SpeedPlsSel,  Menue_display, Menue_input,{0xDA,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xBF}},
		{DISP_BRN_WHT, SLCT_RED_BLUE,14,14,12, Menue_SpeedPlsSel,  Menue_display, Menue_input,{0xB3}},
		{DISP_BRN_WHT, SLCT_RED_BLUE,15,21,12, Menue_SpeedPlsSel,  Menue_display, Menue_input," SPEED "},
		{DISP_BRN_WHT, SLCT_RED_BLUE,22,24,12, Menue_SpeedPlsSel,  Menue_display, Menue_input,{0x18,0xFF,0xB3}},
		{DISP_BRN_WHT, SLCT_RED_BLUE,14,24,13, Menue_SpeedPlsSel,  Menue_display, Menue_input,{0xC0,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xD9}},


		{DISP_BRN_WHT, SLCT_RED_BLUE,14,24,15, Menue_SpeedMnsSel,  Menue_display, Menue_input,{0xDA,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xBF}},
		{DISP_BRN_WHT, SLCT_RED_BLUE,14,14,16, Menue_SpeedMnsSel,  Menue_display, Menue_input,{0xB3}},
		{DISP_BRN_WHT, SLCT_RED_BLUE,15,21,16, Menue_SpeedMnsSel,  Menue_display, Menue_input," SPEED "},
		{DISP_BRN_WHT, SLCT_RED_BLUE,22,24,16, Menue_SpeedMnsSel,  Menue_display, Menue_input,{0x19,0xFF,0xB3}},
		{DISP_BRN_WHT, SLCT_RED_BLUE,14,24,17, Menue_SpeedMnsSel,  Menue_display, Menue_input,{0xC0,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xD9}},


		{DISP_BRN_WHT, SLCT_RED_BLUE,26,36,11, Menue_StartSel,     Menue_display, Menue_input,{0xDA,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xBF}},
		{DISP_BRN_WHT, SLCT_RED_BLUE,26,26,12, Menue_StartSel,     Menue_display, Menue_input,{0xB3}},
		{DISP_BRN_WHT, SLCT_RED_BLUE,27,35,12, Menue_StartSel,     Menue_display, Menue_input,"  START  "},
		{DISP_BRN_WHT, SLCT_RED_BLUE,36,36,12, Menue_StartSel,     Menue_display, Menue_input,{0xB3}},
		{DISP_BRN_WHT, SLCT_RED_BLUE,26,36,13, Menue_StartSel,     Menue_display, Menue_input,{0xC0,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xD9}},


		{DISP_BRN_WHT, SLCT_RED_BLUE,26,36,15, Menue_StopSel,      Menue_display, Menue_input,{0xDA,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xBF}},
		{DISP_BRN_WHT, SLCT_RED_BLUE,26,26,16, Menue_StopSel,      Menue_display, Menue_input,{0xB3}},
		{DISP_BRN_WHT, SLCT_RED_BLUE,27,35,16, Menue_StopSel,      Menue_display, Menue_input,"  STOP   "},
		{DISP_BRN_WHT, SLCT_RED_BLUE,36,36,16, Menue_StopSel,      Menue_display, Menue_input,{0xB3}},
		{DISP_BRN_WHT, SLCT_RED_BLUE,26,36,17, Menue_StopSel,      Menue_display, Menue_input,{0xC0,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xD9}},


		{0, 0, 0, 0, 0, 0, 0, 0, " "}  //LAST ENTRY
};
// *INDENT-ON*
/******************************************************************************/
/*------------------------------Global variables------------------------------*/
/******************************************************************************/
Display_Time displayTime;

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void Menue_display(sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
	conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_display);
	conio_ascii_gotoxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
	conio_ascii_cputs (DISPLAYMENU, pdisplayentry->text);
}

sint32 Menue_input (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
	//    __debug ();
	return (0);
}

void Menue_noAction(sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
}

void Display_update_timeElapsed(void)
{
	displayTime.msec++;
	if((displayTime.msec % 10)==0)
	{
		displayTime.msec = 0;
		displayTime.sec++;
		if((displayTime.sec % 60)==0)
		{
			displayTime.sec= 0;
			displayTime.min++;
			if((displayTime.min % 60)==0)
			{
				displayTime.min= 0;
				displayTime.hour++;
			}
		}
	}
}

void Menue_displayTime (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
	conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_display);
	conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"Time Elapsed %02d:%02d:%02d", displayTime.hour, displayTime.min, displayTime.sec);
}

void Menue_ResetTime(sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
	conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_display);
	conio_ascii_gotoxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
	conio_ascii_cputs (DISPLAYMENU, pdisplayentry->text);
}

void Menue_ResetTimeSel(sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
	conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
	conio_ascii_gotoxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
	conio_ascii_cputs (DISPLAYMENU, pdisplayentry->text);
	if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
	{
		touch_driver.touchmode &= ~MASK_TOUCH_UP;   //clear
		displayTime.msec= 0;
		displayTime.sec= 0;
		displayTime.min= 0;
		displayTime.hour= 0;
	}
}

void Menue_displaySpeed (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
	conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
	conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_display);
	conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"Speed: %4.0f rpm", PmsmFoc_speedcontrol_getSpeed(&g_motorCtrl.pmsmFoc.speedControl));
}

void Menue_displayRSpeed (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
	conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
	conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_display);
	conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"Ref  : %4.0f rpm", PmsmFoc_speedcontrol_getRefSpeed(&g_motorCtrl.pmsmFoc.speedControl));
}

void Menue_displayPosition (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
	uint32 angle= (IfxGpt12_IncrEnc_getRawPosition(&g_motorCtrl.positionSensor.encoder.incrEncoder)*4*360/g_motorCtrl.positionSensor.encoder.incrEncoder.resolution)%360;
	conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
	conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_display);
	conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"Position: %3d deg", angle);
}
uint8 currenttime,beforetime;
void Menue_displayMode (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
	conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
	conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_display);
	currenttime = displayTime.msec;
	switch (g_motorCtrl.CtrlParms.state)
	{
	case STATE_PhaseCalibration:
		conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"State: %s", "PhaseCal!");
		break;
	case STATE_PositionCalibration:
		conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"State: %s", "PosCal");
		break;
	case STATE_focClosedLoop:
		conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"State: %s", "FOC!");
		break;
	case STATE_tuneCurrentRegulators:
		conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"State: %s", "Tune PI!");
		break;
	case STATE_prePositioning:
		conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"State: %s", "Pre Positioning!");
		break;
	case STATE_motorStop:
		conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"State: %s", "Stop!");
		break;
	case STATE_motorIdle:
		conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"State: %s", "Idle!");
		break;
	case STATE_vfOpenLoop:
		conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"State: %s", "VF Control!");
		break;
	case STATE_enableInverter:
		conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"State: %s", "Enable Inverter!");
		break;
	case STATE_demo:
		conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"State: %s", "Demo");
		break;
	default:
		break;
	}
}

void Menue_CalibrateSel(sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
	conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
	conio_ascii_gotoxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
	conio_ascii_cputs (DISPLAYMENU, pdisplayentry->text);
	if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
	{
		/* Go toSTATE_PhaseCalibration */
		PmsmFoc_Interface_calMotor(&g_motorCtrl);
		touch_driver.touchmode &= ~MASK_TOUCH_UP;   //clear
	}
}

void Menue_DemoSel(sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
	conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
	conio_ascii_gotoxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
	conio_ascii_cputs (DISPLAYMENU, pdisplayentry->text);
	if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
	{
		PmsmFoc_Interface_setDemo(&g_motorCtrl);
		touch_driver.touchmode &= ~MASK_TOUCH_UP;   //clear
	}
}

void Menue_SpeedPlsSel(sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
	conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
	conio_ascii_gotoxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
	conio_ascii_cputs (DISPLAYMENU, pdisplayentry->text);
	if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
	{
		PmsmFoc_Interface_plsMotorTargetSpeed(&g_motorCtrl);
		touch_driver.touchmode &= ~MASK_TOUCH_UP;   //clear
	}
}

void Menue_SpeedMnsSel(sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
	conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
	conio_ascii_gotoxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
	conio_ascii_cputs (DISPLAYMENU, pdisplayentry->text);
	if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
	{
		PmsmFoc_Interface_mnsMotorTargetSpeed(&g_motorCtrl);
		touch_driver.touchmode &= ~MASK_TOUCH_UP;   //clear
	}
}

void Menue_StartSel(sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
	conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
	conio_ascii_gotoxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
	conio_ascii_cputs (DISPLAYMENU, pdisplayentry->text);
	if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
	{
		/* Go toSTATE_focClosedLoop orSTATE_PhaseCalibration */
		PmsmFoc_Interface_startMotor(&g_motorCtrl);
		touch_driver.touchmode &= ~MASK_TOUCH_UP;   //clear
	}
}

void Menue_StopSel(sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
	conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
	conio_ascii_gotoxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
	conio_ascii_cputs (DISPLAYMENU, pdisplayentry->text);
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
		/* Go toSTATE_motorStop */
		PmsmFoc_Interface_stopMotor(&g_motorCtrl);
		if(g_motorCtrl.interface.CurrnetIfMode == STOPPING_MODE)
		{
			/* ignore the command from touch_periodic */
			/* Command stop selection by force */
			touch_event.userctrl = TRUE;
		}
		else
		{
    		touch_driver.touchmode &= ~MASK_TOUCH_UP; //clear
			touch_event.userctrl = FALSE;
		}

	}
}

void showmenu (sint16 x, sint16 y, TDISPLAYENTRY * pmenulist)
{
    sint32 i;
    conio_ascii_textbackground (DISPLAYMENU, MENU_BACKGRND);
    conio_ascii_clrscr (DISPLAYMENU);
    conio_ascii_textcolor (DISPLAYMENU, COLOR_BLACK);
    conio_ascii_textbackground (DISPLAYMENU, COLOR_CYAN);
    for (i = 0; pmenulist[i].select != 0; i += 1)
    {
        if ((x >= pmenulist[i].xmin) && (x <= pmenulist[i].xmax) && (y == pmenulist[i].y))
        {
            if (conio_driver.dialogmode == DIALOGOFF)
            {
                if (pmenulist[i].display == 0)
                    Menue_display (i, (struct DISPLAYENTRY *) &pmenulist[i]);
                else
                {
                    pmenulist[i].select (i, (struct DISPLAYENTRY *) &pmenulist[i]);
                }
            }
        }
        else
        {
            if (pmenulist[i].display == 0)
				Menue_display(i, (struct DISPLAYENTRY *) &pmenulist[i]);
            else
            {
                pmenulist[i].display (i, (struct DISPLAYENTRY *) &pmenulist[i]);
            }
        }
    }
}

void showsdtou0 (void)
{
  	conio_ascii_printfxy (DISPLAYSTDOUT0, 0, 0, (uint8 *)SW_NAME);
	conio_ascii_printfxy (DISPLAYSTDOUT0, 0, 1, (uint8 *)"SW: V1.0.2, HW V3.2");
	conio_ascii_printfxy (DISPLAYSTDOUT0, 0, 3, (uint8 *)"Speed Ref [rpm] = %.1f %c\n", g_motorCtrl.pmsmFoc.speedControl.refSpeed);
	conio_ascii_printfxy (DISPLAYSTDOUT0, 0, 4, (uint8 *)"Speed Meas[rpm] = %.1f %c\n", g_motorCtrl.pmsmFoc.speedControl.measSpeed);

	conio_ascii_printfxy (DISPLAYSTDOUT0, 0, 6, (uint8 *)"Iu[A] = %.3f %c\n", g_motorCtrl.inverter.phaseCurrentSense.curVO1.value);
	conio_ascii_printfxy (DISPLAYSTDOUT0, 0, 7, (uint8 *)"Iv[A] = %.3f %c\n", g_motorCtrl.inverter.phaseCurrentSense.curVO2.value);
	conio_ascii_printfxy (DISPLAYSTDOUT0, 0, 8, (uint8 *)"Iw[A] = %.3f %c\n", g_motorCtrl.inverter.phaseCurrentSense.curVO3.value);

	conio_ascii_printfxy (DISPLAYSTDOUT0, 0, 10, (uint8 *)"IqRef [A] = %.2f %c\n", g_motorCtrl.pmsmFoc.idqRef.imag);
	conio_ascii_printfxy (DISPLAYSTDOUT0, 0, 11, (uint8 *)"IqMeas[A] = %.2f %c\n", g_motorCtrl.pmsmFoc.idqMeas.imag);

	conio_ascii_printfxy (DISPLAYSTDOUT0, 20, 10, (uint8 *)"IdRef[A] = %.2f %c\n", g_motorCtrl.pmsmFoc.idqRef.real);
	conio_ascii_printfxy (DISPLAYSTDOUT0, 20, 11, (uint8 *)"IdMeas[A] = %.2f %c\n", g_motorCtrl.pmsmFoc.idqMeas.real);

	conio_ascii_printfxy (DISPLAYSTDOUT0, 0, 13, (uint8 *)"VqRef [p.u.] = %.2f %c\n", g_motorCtrl.pmsmFoc.vdqRef.imag);
	conio_ascii_printfxy (DISPLAYSTDOUT0, 0, 14, (uint8 *)"VdRef [p.u.] = %.2f %c\n", g_motorCtrl.pmsmFoc.vdqRef.real);

	conio_ascii_printfxy (DISPLAYSTDOUT0, 0, 16, (uint8 *)"ValphaRef[p.u.] = %.2f %c\n", g_motorCtrl.pmsmFoc.vabRef.imag);
	conio_ascii_printfxy (DISPLAYSTDOUT0, 0, 17, (uint8 *)"VbetaRef [p.u.] = %.2f %c\n", g_motorCtrl.pmsmFoc.vabRef.real);
}

