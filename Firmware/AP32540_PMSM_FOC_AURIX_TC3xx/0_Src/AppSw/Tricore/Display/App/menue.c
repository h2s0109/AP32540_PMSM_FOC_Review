/**
 * \file mebnu.c
 * \brief Source file for our menu
 *
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.

 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/
#include <Cpu/Std/Ifx_Types.h>
#include <stdio.h>
#include <string.h>
#if GENERAL_TFTKIT
#include "Configuration.h"
#endif
#include "Display_Cfg_AppKitTft_TC387A.h"
#include "conio_tft.h"
#include "touch.h"
#if GENERAL_TFTKIT
//#include "main_appl.h"
#include "RTC.h"
#include "background_light.h"
#include "Measurement.h"
#endif

#include "menue.h"
#include "PmsmFoc_Interface.h"
/******************************************************************************/
/*------------------------Inline Function Prototypes--------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-------------------------Function Prototypes--------------------------------*/
/******************************************************************************/
void Menue_display(sint32 ind, TDISPLAYENTRY * pDispEntry);
sint32 Menue_input (sint32 ind, TDISPLAYENTRY * pDispEntry);

void Menue_displayTime(sint32 ind, TDISPLAYENTRY * pDispEntry);
void Menue_ResetTimeSel(sint32 ind, TDISPLAYENTRY * pDispEntry);
void Menue_ResetTime(sint32 ind, TDISPLAYENTRY *pDispEntry);
void Menue_noAction (sint32 ind, TDISPLAYENTRY * pDispEntry);
void Menue_displaySpeed (sint32 ind, TDISPLAYENTRY * pDispEntry);
void Menue_displayRSpeed (sint32 ind, TDISPLAYENTRY * pDispEntry);
void Menue_displayOffset (sint32 ind, TDISPLAYENTRY * pDispEntry);
void Menue_displayMode (sint32 ind, TDISPLAYENTRY * pDispEntry);

void Menue_CalibrateSel(sint32 ind, TDISPLAYENTRY * pDispEntry);
void Menue_DemoSel(sint32 ind, TDISPLAYENTRY * pDispEntry);
void Menue_SpeedPlsSel(sint32 ind, TDISPLAYENTRY * pDispEntry);
void Menue_SpeedMnsSel(sint32 ind, TDISPLAYENTRY * pDispEntry);
void Menue_StartSel(sint32 ind, TDISPLAYENTRY * pDispEntry);
void Menue_StopSel(sint32 ind, TDISPLAYENTRY * pDispEntry);

/******************************************************************************/
/*------------------------Private Variables/Constants-------------------------*/
/******************************************************************************/

#define DISP_CYAN_BLK   (COLOR_CYAN << 4) | COLOR_BLACK        //Display background color cyan, text color black
#define DISP_BRN_WHT   (COLOR_BROWN << 4) | COLOR_WHITE        //Display background color brown, text color black
#define SLCT_BLK_YELW   (COLOR_BLACK << 4) | COLOR_YELLOW      //Selection background color black, text color yellow
#define SLCT_RED_BLUE   (COLOR_RED << 4) | COLOR_BLUE      //Selection background color red, text color yellow
#define DISP_BLUE_YELW   (COLOR_BLUE << 4) | COLOR_YELLOW        //Display background color blue, text color yellow
// *INDENT-OFF*
const TDISPLAYENTRY menulist[] = {
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 22, 0, Menue_display, Menue_display, Menue_input,"PMSM_FOC_AURIX_TC3xx"},        //TFT Main Menue
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 22, 1, Menue_display, Menue_display, Menue_input,"SW V1.0.2, HW V3.2"},        //TFT Main Menue

		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 22, 3, Menue_noAction, Menue_displayTime, Menue_input,"Time Elapsed 00:00:00"},
		//{DISP_BRN_WHT,  SLCT_RED_BLUE, 30,39, 2, Menue_ResetTimeSel, Menue_ResetTime, Menue_input,{0xDA,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xBF}},
		//{DISP_BRN_WHT,  SLCT_RED_BLUE, 30,39, 3, Menue_ResetTimeSel, Menue_ResetTime, Menue_input,{0xB3,0xFF, 'R', 'E', 'S', 'E', 'T',0xFF,0xB3}},
		//{DISP_BRN_WHT,  SLCT_RED_BLUE, 30,39, 4, Menue_ResetTimeSel, Menue_ResetTime, Menue_input,{0xC0,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xD9}},
		{DISP_BRN_WHT, SLCT_RED_BLUE, 29,39, 3, Menue_ResetTimeSel, Menue_ResetTime, Menue_input,"Reset Time"},

		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1,38, 5, Menue_noAction, Menue_display,       Menue_input,{0xDA,0xC4, 'S', 't', 'a', 't', 'u', 's',0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xBF}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 1, 6, Menue_noAction, Menue_display,       Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 2,17, 6, Menue_noAction, Menue_displaySpeed,  Menue_input,"Speed: 0 rpm"},
		{DISP_BLUE_YELW, DISP_BLUE_YELW,21,36, 6, Menue_noAction, Menue_displayOffset, Menue_input,"Offset: 0 deg"},
		{DISP_BLUE_YELW, DISP_BLUE_YELW,38,38, 6, Menue_noAction, Menue_display,       Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 1, 7, Menue_noAction, Menue_display,       Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW,38,38, 7, Menue_noAction, Menue_display,       Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 2,17, 8, Menue_noAction, Menue_displayRSpeed, Menue_input,"Ref  : 0 rpm"},
		{DISP_BLUE_YELW, DISP_BLUE_YELW,21,38, 8, Menue_noAction, Menue_displayMode,   Menue_input,"Mode  : Halted !"},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 1, 8, Menue_noAction, Menue_display,       Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW,38,38, 8, Menue_noAction, Menue_display,       Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1,38, 9, Menue_noAction, Menue_display,       Menue_input,{0xC0,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xD9}},

		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1,38, 10, Menue_noAction, Menue_display, Menue_input,{0xDA,0xC4, 'C', 'o', 'n', 't', 'r', 'o', 'l',0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xBF}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 1, 11, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW,38,38, 11, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 1, 12, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW,38,38, 12, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 1, 13, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW,38,38, 13, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 1, 14, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW,38,38, 14, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 1, 15, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW,38,38, 15, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 1, 16, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW,38,38, 16, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1, 1, 17, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW,38,38, 17, Menue_noAction, Menue_display, Menue_input,{0xB3}},
		{DISP_BLUE_YELW, DISP_BLUE_YELW, 1,38, 18, Menue_noAction, Menue_display, Menue_input,{0xC0,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xD9}},

		{DISP_BRN_WHT, SLCT_RED_BLUE, 3,12,11, Menue_CalibrateSel, Menue_display, Menue_input,{0xDA,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xBF}},
		{DISP_BRN_WHT, SLCT_RED_BLUE, 3, 3,12, Menue_CalibrateSel, Menue_display, Menue_input,{0xB3}},
		{DISP_BRN_WHT, SLCT_RED_BLUE, 4,11,12, Menue_CalibrateSel, Menue_display, Menue_input,"  CAL   "},
		{DISP_BRN_WHT, SLCT_RED_BLUE,12,12,12, Menue_CalibrateSel, Menue_display, Menue_input,{0xB3}},
		{DISP_BRN_WHT, SLCT_RED_BLUE, 3,12,13, Menue_CalibrateSel, Menue_display, Menue_input,{0xC0,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xD9}},

		{DISP_BRN_WHT, SLCT_RED_BLUE, 3,12,15, Menue_DemoSel,      Menue_display, Menue_input,{0xDA,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xBF}},
		{DISP_BRN_WHT, SLCT_RED_BLUE, 3, 3,16, Menue_DemoSel,      Menue_display, Menue_input,{0xB3}},
		{DISP_BRN_WHT, SLCT_RED_BLUE, 4,11,16, Menue_DemoSel,      Menue_display, Menue_input,"  DEMO  "},
		{DISP_BRN_WHT, SLCT_RED_BLUE,12,12,16, Menue_DemoSel,      Menue_display, Menue_input,{0xB3}},
		{DISP_BRN_WHT, SLCT_RED_BLUE, 3,12,17, Menue_DemoSel,      Menue_display, Menue_input,{0xC0,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xD9}},

		{DISP_BRN_WHT, SLCT_RED_BLUE,14,24,11, Menue_SpeedPlsSel,  Menue_display, Menue_input,{0xDA,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xBF}},
		{DISP_BRN_WHT, SLCT_RED_BLUE,14,14,12, Menue_SpeedPlsSel,  Menue_display, Menue_input,{0xB3}},
		{DISP_BRN_WHT, SLCT_RED_BLUE,15,21,12, Menue_SpeedPlsSel,  Menue_display, Menue_input," SPEED "},
		{DISP_BRN_WHT, SLCT_RED_BLUE,22,24,12, Menue_SpeedPlsSel,  Menue_display, Menue_input,{0x18,0xFF,0xB3}},
		{DISP_BRN_WHT, SLCT_RED_BLUE,14,24,13, Menue_SpeedPlsSel,  Menue_display, Menue_input,{0xC0,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xD9}},


		{DISP_BRN_WHT, SLCT_RED_BLUE,14,24,15, Menue_SpeedMnsSel,  Menue_display, Menue_input,{0xDA,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xBF}},
		{DISP_BRN_WHT, SLCT_RED_BLUE,14,14,16, Menue_SpeedMnsSel,  Menue_display, Menue_input,{0xB3}},
		{DISP_BRN_WHT, SLCT_RED_BLUE,15,21,16, Menue_SpeedMnsSel,  Menue_display, Menue_input," SPEED "},
		{DISP_BRN_WHT, SLCT_RED_BLUE,22,24,16, Menue_SpeedMnsSel,  Menue_display, Menue_input,{0x19,0xFF,0xB3}},
		{DISP_BRN_WHT, SLCT_RED_BLUE,14,24,17, Menue_SpeedMnsSel,  Menue_display, Menue_input,{0xC0,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xD9}},


		{DISP_BRN_WHT, SLCT_RED_BLUE,26,36,11, Menue_StartSel,     Menue_display, Menue_input,{0xDA,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xBF}},
		{DISP_BRN_WHT, SLCT_RED_BLUE,26,26,12, Menue_StartSel,     Menue_display, Menue_input,{0xB3}},
		{DISP_BRN_WHT, SLCT_RED_BLUE,27,35,12, Menue_StartSel,     Menue_display, Menue_input,"  START  "},
		{DISP_BRN_WHT, SLCT_RED_BLUE,36,36,12, Menue_StartSel,     Menue_display, Menue_input,{0xB3}},
		{DISP_BRN_WHT, SLCT_RED_BLUE,26,36,13, Menue_StartSel,     Menue_display, Menue_input,{0xC0,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xD9}},


		{DISP_BRN_WHT, SLCT_RED_BLUE,26,36,15, Menue_StopSel,      Menue_display, Menue_input,{0xDA,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xBF}},
		{DISP_BRN_WHT, SLCT_RED_BLUE,26,26,16, Menue_StopSel,      Menue_display, Menue_input,{0xB3}},
		{DISP_BRN_WHT, SLCT_RED_BLUE,27,35,16, Menue_StopSel,      Menue_display, Menue_input,"  STOP   "},
		{DISP_BRN_WHT, SLCT_RED_BLUE,36,36,16, Menue_StopSel,      Menue_display, Menue_input,{0xB3}},
		{DISP_BRN_WHT, SLCT_RED_BLUE,26,36,17, Menue_StopSel,      Menue_display, Menue_input,{0xC0,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xD9}},


		{0, 0, 0, 0, 0, 0, 0, 0, " "}  //LAST ENTRY
};
// *INDENT-ON*
/******************************************************************************/
/*------------------------------Global variables------------------------------*/
/******************************************************************************/
Display_Time displayTime;
extern MotorControl			g_motorControl;

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void Menue_display(sint32 ind, TDISPLAYENTRY *pDispEntry)
{
	conio_ascii_textattr (DISPLAYMENU, pDispEntry->color_display);
	conio_ascii_gotoxy (DISPLAYMENU, pDispEntry->xmin, pDispEntry->y);
	conio_ascii_cputs (DISPLAYMENU, pDispEntry->text);
}

sint32 Menue_input (sint32 ind, TDISPLAYENTRY * pDispEntry)
{
	//    __debug ();
	return (0);
}

void Menue_noAction(sint32 ind, TDISPLAYENTRY * pDispEntry)
{
}

void Display_update_timeElapsed(void)
{
	displayTime.sec++;
	if((displayTime.sec % 60)==0)
	{
		displayTime.sec= 0;
		displayTime.min++;
		if((displayTime.min % 60)==0)
		{
			displayTime.min= 0;
			displayTime.hour++;
		}
	}
}

void Menue_displayTime (sint32 ind, TDISPLAYENTRY * pDispEntry)
{
	conio_ascii_textattr (DISPLAYMENU, pDispEntry->color_display);
	conio_ascii_printfxy(DISPLAYMENU, pDispEntry->xmin, pDispEntry->y, (const uint8 *)"Time Elapsed %02d:%02d:%02d", displayTime.hour, displayTime.min, displayTime.sec);
}

void Menue_ResetTime(sint32 ind, TDISPLAYENTRY *pDispEntry)
{
	conio_ascii_textattr (DISPLAYMENU, pDispEntry->color_display);
	conio_ascii_gotoxy (DISPLAYMENU, pDispEntry->xmin, pDispEntry->y);
	conio_ascii_cputs (DISPLAYMENU, pDispEntry->text);
}

void Menue_ResetTimeSel(sint32 ind, TDISPLAYENTRY * pDispEntry)
{
	conio_ascii_textattr (DISPLAYMENU, pDispEntry->color_select);
	conio_ascii_gotoxy (DISPLAYMENU, pDispEntry->xmin, pDispEntry->y);
	conio_ascii_cputs (DISPLAYMENU, pDispEntry->text);
	if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
	{
		touch_driver.touchmode &= ~MASK_TOUCH_UP;   //clear
		displayTime.sec= 0;
		displayTime.min= 0;
		displayTime.hour= 0;
	}
}

void Menue_displaySpeed (sint32 ind, TDISPLAYENTRY * pDispEntry)
{
	conio_ascii_textattr (DISPLAYMENU, pDispEntry->color_select);
	conio_ascii_textattr (DISPLAYMENU, pDispEntry->color_display);
	conio_ascii_printfxy(DISPLAYMENU, pDispEntry->xmin, pDispEntry->y, (const uint8 *)"Speed: %4.0f rpm", PmsmFoc_SpeedControl_getSpeed(&g_motorControl.pmsmFoc.speedControl));
}

void Menue_displayRSpeed (sint32 ind, TDISPLAYENTRY * pDispEntry)
{
	conio_ascii_textattr (DISPLAYMENU, pDispEntry->color_select);
	conio_ascii_textattr (DISPLAYMENU, pDispEntry->color_display);
	conio_ascii_printfxy(DISPLAYMENU, pDispEntry->xmin, pDispEntry->y, (const uint8 *)"Ref  : %4.0f rpm", PmsmFoc_SpeedControl_getRefSpeed(&g_motorControl.pmsmFoc.speedControl));
}

void Menue_displayOffset (sint32 ind, TDISPLAYENTRY * pDispEntry)
{
	uint32 angle= IfxGpt12_IncrEnc_getRawPosition(&g_motorControl.positionSensor.encoder.incrEncoder)* 360/g_motorControl.positionSensor.encoder.incrEncoder.resolution;
	conio_ascii_textattr (DISPLAYMENU, pDispEntry->color_select);
	conio_ascii_textattr (DISPLAYMENU, pDispEntry->color_display);
	conio_ascii_printfxy(DISPLAYMENU, pDispEntry->xmin, pDispEntry->y, (const uint8 *)"Position: %3d deg", angle);
}

#if 0
void Menue_displayMode (sint32 ind, TDISPLAYENTRY * pDispEntry)
{
	uint8 status = 0; //= Motor_getRunningStatus();
	conio_ascii_textattr (DISPLAYMENU, pDispEntry->color_select);
	conio_ascii_textattr (DISPLAYMENU, pDispEntry->color_display);
	if(status == 0)
		conio_ascii_printfxy(DISPLAYMENU, pDispEntry->xmin, pDispEntry->y, (const uint8 *)"Mode  : %s", "Stopped !");
	else if(status == 1)
		conio_ascii_printfxy(DISPLAYMENU, pDispEntry->xmin, pDispEntry->y, (const uint8 *)"Mode  : %s", "Running !");
	else if(status == 2)
		conio_ascii_printfxy(DISPLAYMENU, pDispEntry->xmin, pDispEntry->y, (const uint8 *)"Mode  : %s", "Demo !");
}
#endif

void Menue_displayMode (sint32 ind, TDISPLAYENTRY * pDispEntry)
{
	conio_ascii_textattr (DISPLAYMENU, pDispEntry->color_select);
	conio_ascii_textattr (DISPLAYMENU, pDispEntry->color_display);

	switch (g_motorControl.controlParameters.state)
	{
	case StateMachine_calibration:
		conio_ascii_printfxy(DISPLAYMENU, pDispEntry->xmin, pDispEntry->y, (const uint8 *)"State: %s", "Calibration!");
		break;
	case StateMachine_focClosedLoop:
		conio_ascii_printfxy(DISPLAYMENU, pDispEntry->xmin, pDispEntry->y, (const uint8 *)"State: %s", "FOC!");
		break;
	case StateMachine_tuneCurrentRegulators:
		conio_ascii_printfxy(DISPLAYMENU, pDispEntry->xmin, pDispEntry->y, (const uint8 *)"State: %s", "Tune PI!");
		break;
	case StateMachine_prePositioning:
		conio_ascii_printfxy(DISPLAYMENU, pDispEntry->xmin, pDispEntry->y, (const uint8 *)"State: %s", "Pre Positioning!");
		break;
	case StateMachine_motorStop:
		conio_ascii_printfxy(DISPLAYMENU, pDispEntry->xmin, pDispEntry->y, (const uint8 *)"State: %s", "Stop!");
		break;
	case StateMachine_motorIdle:
		conio_ascii_printfxy(DISPLAYMENU, pDispEntry->xmin, pDispEntry->y, (const uint8 *)"State: %s", "Idle!");
		break;
	case StateMachine_vfOpenLoop:
		conio_ascii_printfxy(DISPLAYMENU, pDispEntry->xmin, pDispEntry->y, (const uint8 *)"State: %s", "VF Control!");
		break;
	case StateMachine_enableInverter:
		conio_ascii_printfxy(DISPLAYMENU, pDispEntry->xmin, pDispEntry->y, (const uint8 *)"State: %s", "Enable Inverter!");
		break;
	default:
		break;
	}
}

void Menue_CalibrateSel(sint32 ind, TDISPLAYENTRY * pDispEntry)
{
	conio_ascii_textattr (DISPLAYMENU, pDispEntry->color_select);
	conio_ascii_gotoxy (DISPLAYMENU, pDispEntry->xmin, pDispEntry->y);
	conio_ascii_cputs (DISPLAYMENU, pDispEntry->text);
	if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
	{
		if(g_motorControl.controlParameters.state == StateMachine_motorStop)
		{
			PmsmFoc_PhaseCurrentSense_resetCalibrationStatus(&g_motorControl.inverter.phaseCurrentSense);
			PmsmFoc_resetEncoderCalibrationStatus(&g_motorControl);
			PmsmFoc_PositionAcquisition_init(&g_motorControl.positionSensor, PositionAcquisition_SensorType_Encoder);
			PmsmFoc_Interface_startMotor(&g_motorControl);
		}
		touch_driver.touchmode &= ~MASK_TOUCH_UP;   //clear
	}
}

void Menue_DemoSel(sint32 ind, TDISPLAYENTRY * pDispEntry)
{
	conio_ascii_textattr (DISPLAYMENU, pDispEntry->color_select);
	conio_ascii_gotoxy (DISPLAYMENU, pDispEntry->xmin, pDispEntry->y);
	conio_ascii_cputs (DISPLAYMENU, pDispEntry->text);
	if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
	{
		PmsmFoc_Interface_setDemo(&g_motorControl);
		touch_driver.touchmode &= ~MASK_TOUCH_UP;   //clear
	}
}

void Menue_SpeedPlsSel(sint32 ind, TDISPLAYENTRY * pDispEntry)
{
	float32 refSpeed;
	float32 maxSpeed;
	conio_ascii_textattr (DISPLAYMENU, pDispEntry->color_select);
	conio_ascii_gotoxy (DISPLAYMENU, pDispEntry->xmin, pDispEntry->y);
	conio_ascii_cputs (DISPLAYMENU, pDispEntry->text);
	if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
	{
		maxSpeed = PmsmFoc_SpeedControl_getMaxSpeed(&g_motorControl.pmsmFoc.speedControl);
		refSpeed = PmsmFoc_SpeedControl_getRefSpeed(&g_motorControl.pmsmFoc.speedControl);

		if(refSpeed < maxSpeed)
			refSpeed = refSpeed + 100.0f;
		else
			refSpeed = maxSpeed;

		PmsmFoc_Interface_setMotorTargetSpeed(&g_motorControl, refSpeed);


		touch_driver.touchmode &= ~MASK_TOUCH_UP;   //clear
	}
}

void Menue_SpeedMnsSel(sint32 ind, TDISPLAYENTRY * pDispEntry)
{
	float32 refSpeed;
	float32 minSpeed;
	conio_ascii_textattr (DISPLAYMENU, pDispEntry->color_select);
	conio_ascii_gotoxy (DISPLAYMENU, pDispEntry->xmin, pDispEntry->y);
	conio_ascii_cputs (DISPLAYMENU, pDispEntry->text);
	if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
	{
		refSpeed = PmsmFoc_SpeedControl_getRefSpeed(&g_motorControl.pmsmFoc.speedControl);
		minSpeed = PmsmFoc_SpeedControl_getMinSpeed(&g_motorControl.pmsmFoc.speedControl);

		if(refSpeed > minSpeed)
			refSpeed = refSpeed - 100.0f;
		else
			refSpeed = minSpeed;

		PmsmFoc_Interface_setMotorTargetSpeed(&g_motorControl, refSpeed);

		touch_driver.touchmode &= ~MASK_TOUCH_UP;   //clear
	}
}

void Menue_StartSel(sint32 ind, TDISPLAYENTRY * pDispEntry)
{
	conio_ascii_textattr (DISPLAYMENU, pDispEntry->color_select);
	conio_ascii_gotoxy (DISPLAYMENU, pDispEntry->xmin, pDispEntry->y);
	conio_ascii_cputs (DISPLAYMENU, pDispEntry->text);
	if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
	{
		PmsmFoc_Interface_startMotor(&g_motorControl);
		touch_driver.touchmode &= ~MASK_TOUCH_UP;   //clear
	}
}

void Menue_StopSel(sint32 ind, TDISPLAYENTRY * pDispEntry)
{
	conio_ascii_textattr (DISPLAYMENU, pDispEntry->color_select);
	conio_ascii_gotoxy (DISPLAYMENU, pDispEntry->xmin, pDispEntry->y);
	conio_ascii_cputs (DISPLAYMENU, pDispEntry->text);
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
    	touch_driver.touchmode &= ~MASK_TOUCH_UP; //clear
		PmsmFoc_Interface_stopMotor(&g_motorControl);
	}
}

void showmenu (sint16 x, sint16 y, TDISPLAYENTRY * pmenulist)
{
    sint32 i;
    conio_ascii_textbackground (DISPLAYMENU, MENU_BACKGRND);
    conio_ascii_clrscr (DISPLAYMENU);
    conio_ascii_textcolor (DISPLAYMENU, COLOR_BLACK);
    conio_ascii_textbackground (DISPLAYMENU, COLOR_CYAN);
    for (i = 0; pmenulist[i].select != 0; i += 1)
    {
        if ((x >= pmenulist[i].xmin) && (x <= pmenulist[i].xmax) && (y == pmenulist[i].y))
        {
            if (conio_driver.dialogmode == DIALOGOFF)
            {
                if (pmenulist[i].display == 0)
                    Menue_display (i, (struct DISPLAYENTRY *) &pmenulist[i]);
                else
                {
                    pmenulist[i].select (i, (struct DISPLAYENTRY *) &pmenulist[i]);
                }
            }
        }
        else
        {
            if (pmenulist[i].display == 0)
				Menue_display(i, (struct DISPLAYENTRY *) &pmenulist[i]);
            else
            {
                pmenulist[i].display (i, (struct DISPLAYENTRY *) &pmenulist[i]);
            }
        }
    }
}
