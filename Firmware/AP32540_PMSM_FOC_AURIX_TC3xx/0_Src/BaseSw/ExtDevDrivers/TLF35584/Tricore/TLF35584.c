/*
 * \file TLF35584.c
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *                            IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "TLF35584.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/
#define TLF_BUFFER_SIZE 1   /**< \brief Tx/Rx Buffer size */

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*------------------------------Global variables------------------------------*/
/******************************************************************************/
static IfxTLF35584      *driverData;     /**< \brief Pointer to TLF35584 internal data */

/******************************************************************************/
/*-------------------------Function Prototypes--------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*------------------------Private Variables/Constants-------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/
/** \brief TLF initialization
 *
 * This function initializes Qspix in master mode.
 */

void IfxTLF35584_init(IfxTLF35584 *tlf35584, IfxTLF35584_Config *config)
{
	driverData= tlf35584;

	tlf35584->spiChannel= config->spiChannel;
	tlf35584->spiIf= config->spiIf;

    /* init buffer area */
    tlf35584->transmitBuffer[0] = 0;
    tlf35584->receiveBuffer[0] = 0;

	/* first we check for A or B-step of TLF */
    /* we read the value from address 0x34 but ignore the returned value */
    IfxTLF35584_readWrite(0x6801);  /* read address 0x34 */
    /* no we read the SPI status flags */
    if ((IfxTLF35584_readWrite(0x3E01)>>1) & 0x4)
    {
    	/* there was an address error, this is not the A-step */
    	/* we reset the ADDRE flag */
        IfxTLF35584_readWrite(0xBE09);  /* SPISF = 0x04 */
        tlf35584->aStep = FALSE;
    }
    else
    {
    	tlf35584->aStep = TRUE;
    }
}

void IfxTLF35584_unprotectRegister(void)
{
    IfxTLF35584_readWrite(0x8756);  /* PROTCFG = 0xAB */
    IfxTLF35584_readWrite(0x87DE);  /* PROTCFG = 0xEF */
    IfxTLF35584_readWrite(0x86AD);  /* PROTCFG = 0x56 */
    IfxTLF35584_readWrite(0x8625);  /* PROTCFG = 0x12 */
}

void IfxTLF35584_protectRegister(void)
{
    IfxTLF35584_readWrite(0x87BE);  /* PROTCFG = 0xDF */
    IfxTLF35584_readWrite(0x8668);  /* PROTCFG = 0x34 */
    IfxTLF35584_readWrite(0x877D);  /* PROTCFG = 0xBE */
    IfxTLF35584_readWrite(0x8795);  /* PROTCFG = 0xCA */
}

void IfxTLF35584_disableWindowWatchdog(void)
{
    uint32 uiWdcfg0;
	/* first we get the value of WDCFG0 to check the window watchdog */
    if (driverData->aStep == TRUE)
        uiWdcfg0 = IfxTLF35584_readWrite(0x0C00);  /* read WDCFG0 (0x06) */
    else
        uiWdcfg0 = IfxTLF35584_readWrite(0x1A00);  /* read RWDCFG0 (0x0D) */
    /* if the WWDEN is cleared then return because the window watchdog is already disabled */
    if (!(uiWdcfg0 & 0x0010)) return;
	/* clear the WWDEN bit */
    uiWdcfg0 &= ~0x0010;
    /* correct the parity */
    if (uiWdcfg0 & 0x0001)
        uiWdcfg0 &= ~0x0001;
    else
        uiWdcfg0 |= 0x0001;
    /* set the write address to 0x06 */
    uiWdcfg0 |= (0x06<<9);
	/* Write back and disable the Window Watchdog */
    IfxTLF35584_readWrite(uiWdcfg0);
}

void IfxTLF35584_enableWindowWatchdog(void)
{
    uint32 uiWdcfg0;
	/* first we get the value of WDCFG0 to check the window watchdog */
    if (driverData->aStep == TRUE)
        uiWdcfg0 = IfxTLF35584_readWrite(0x0C00);  /* read WDCFG0 (0x06) */
    else
        uiWdcfg0 = IfxTLF35584_readWrite(0x1A00);  /* read RWDCFG0 (0x0D) */
    /* if the WWDEN is set then return because the window watchdog is already enabled */
    if (uiWdcfg0 & 0x0010) return;
	/* set the WWDEN bit */
    uiWdcfg0 |= 0x0010;
    /* correct the parity */
    if (uiWdcfg0 & 0x0001)
        uiWdcfg0 &= ~0x0001;
    else
        uiWdcfg0 |= 0x0001;
    /* set the write address to 0x06 */
    uiWdcfg0 |= (0x06<<9);
	/* Write back and enable the Window Watchdog */
    IfxTLF35584_readWrite(uiWdcfg0);
}

void IfxTLF35584_disableErrPinMonitor(void)
{
    uint32 uiSyspcfg;
    if (driverData->aStep == TRUE)
    {
    	/* first we get the value of SYSPCFG0 to check the error pin monitor */
    	uiSyspcfg = IfxTLF35584_readWrite(0x0801);  /* read SYSPCFG0 (0x04) */
        /* if the ERREN is cleared then return because the error pin monitor is already disabled */
        if (!(uiSyspcfg & 0x0004)) return;
    	/* clear the ERREN bit */
        uiSyspcfg &= ~0x0004;
        /* set the write address to 0x04 */
        uiSyspcfg |= (0x04<<9);
        /* parity must not be corrected */
    }
    else
    {
    	/* first we get the value of RSYSPCFG1 to check the error pin monitor */
    	uiSyspcfg = IfxTLF35584_readWrite(0x1800);  /* read RSYSPCFG1 (0x0C) */
        /* if the ERREN is cleared then return because the error pin monitor is already disabled */
        if (!(uiSyspcfg & 0x0010)) return;
    	/* clear the ERREN bit */
        uiSyspcfg &= ~0x0010;
        /* set the write address to 0x05 */
        uiSyspcfg |= (0x05<<9);
        /* correct the parity */
        if (uiSyspcfg & 0x0001)
        	uiSyspcfg &= ~0x0001;
        else
        	uiSyspcfg |= 0x0001;
    }
	/* Write back and disable the error pin monitor */
    IfxTLF35584_readWrite(uiSyspcfg);
}

void IfxTLF35584_enableErrPinMonitor(void)
{
    uint32 uiSyspcfg;
    if (driverData->aStep == TRUE)
    {
    	/* first we get the value of SYSPCFG0 to check the error pin monitor */
    	uiSyspcfg = IfxTLF35584_readWrite(0x0801);  /* read SYSPCFG0 (0x04) */
        /* if the ERREN is set then return because the error pin monitor is already enabled */
        if (!(uiSyspcfg & 0x0004)) return;
    	/* set the ERREN bit */
        uiSyspcfg |= 0x0004;
        /* set the write address to 0x04 */
        uiSyspcfg |= (0x04<<9);
        /* parity must not be corrected */
    }
    else
    {
    	/* first we get the value of SYSPCFG1 to check the error pin monitor */
    	uiSyspcfg = IfxTLF35584_readWrite(0x1800);  /* read SYSPCFG1 (0x0C) */
        /* if the ERREN is set then return because the error pin monitor is already enabled */
        if (!(uiSyspcfg & 0x0010)) return;
    	/* set the ERREN bit */
        uiSyspcfg |= 0x0010;
        /* set the write address to 0x05 */
        uiSyspcfg |= (0x05<<9);
        /* correct the parity */
        if (uiSyspcfg & 0x0001)
        	uiSyspcfg &= ~0x0001;
        else
        	uiSyspcfg |= 0x0001;
    }
	/* Write back and enable the error pin monitor */
    IfxTLF35584_readWrite(uiSyspcfg);
}

void IfxTLF35584_gotoStandbyState(void)
{
    if (driverData->aStep == TRUE)
        IfxTLF35584_readWrite(0x9DD9);  /* DEVCTRL = 0xEC */
    else
    {
        IfxTLF35584_readWrite(0xABD9);  /* DEVCTRL = 0xEC */
        IfxTLF35584_readWrite(0xAC27);  /* DEVCTRLN = ~0xEC */
    }
}

void IfxTLF35584_gotoNormalState(void)
{
    /* Switch TLF to normal state */
    if (driverData->aStep == TRUE)
        IfxTLF35584_readWrite(0x9DD5);  /* DEVCTRL = 0xEA */
    else
    {
        IfxTLF35584_readWrite(0xABD5);  /* DEVCTRL = 0xEA */
        IfxTLF35584_readWrite(0xAC2B);  /* DEVCTRLN = ~0xEA */
    }
}

uint32 IfxTLF35584_readWrite(uint32 send_data)
{
	driverData->transmitBuffer[0] = send_data;

    while (driverData->spiIf.spiGetStatus(driverData->spiChannel) == TRUE)  {};

    driverData->spiIf.spiExchange(driverData->spiChannel, &driverData->transmitBuffer[0],
        &driverData->receiveBuffer[0], IFX_TLF35584_SPI_BUFFER_SIZE);

    /* we wait until our values are read from Qspi */
    while (driverData->spiIf.spiGetStatus(driverData->spiChannel) == TRUE)  {};

    return (driverData->receiveBuffer[0]);
}
