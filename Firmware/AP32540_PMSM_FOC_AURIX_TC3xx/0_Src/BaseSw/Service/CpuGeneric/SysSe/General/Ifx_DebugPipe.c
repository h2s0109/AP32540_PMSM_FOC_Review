 /*
 *
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *                            IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
#include "Ifx_DebugPipe.h"
#include "stdlib.h"
#include "string.h"
#include "IfxCpu_Intrinsics.h"

boolean Ifx_DebugPipe_CompareAndSet(volatile void * dst, uint32 old, uint32 new) {
    return Ifx__cmpAndSwap((unsigned int *) dst, new, old) == old ? TRUE : FALSE;
}

uint8 Ifx_DebugPipe_FifoDist(uint8 high, uint8 low, uint8 size) {

    uint8 res;

    if (high >= low) {
        res = high - low; /* res = size - high + low i.e. res = size + (-res) */
    } else {
        res = size - low + high; /* res = size - high + low i.e. res = size + (-res) */
    }

    return res;
}

boolean Ifx_DebugPipe_FifoWrite(volatile Ifx_DebugPipeBuffer * buffer, char * src, uint8 count) {

    Ifx_DebugPipeBufferControl controlNew;
    Ifx_DebugPipeBufferControl controlOld;

    /* reserve buffer */
    do {
        do {
            controlOld = buffer->control;
            controlNew = controlOld;
            controlNew.data.active = controlNew.data.active + count;

            uint8 pending = Ifx_DebugPipe_FifoDist(controlOld.data.writepos, controlOld.data.readpos, buffer->size);
            uint8 free = (buffer->size - 1) - pending - controlOld.data.active; // -1 because we can't have the counter have same values after writing (would be same state as buffer epty)
            if (free > count) {
                break;
            }
        } while (TRUE);

    } while (Ifx_DebugPipe_CompareAndSet(&(buffer->control.value), controlOld.value, controlNew.value) == FALSE);

    /* write data */
    uint32 startpos = (controlOld.data.writepos + controlOld.data.active) % (buffer->size);
    uint32 stoppos = startpos + count;
    for (uint32 i = startpos; i < stoppos; i++) {
        buffer->data[i % (buffer->size)] = src[i - startpos];
    }

    /* increment ready and notify that data is readable if possible */
    do {
        controlOld = buffer->control;
        controlNew = controlOld;
        controlNew.data.ready = controlNew.data.ready + count;
        if (controlNew.data.ready == controlNew.data.active) {
            /* we're the last writer, mark data as readable */
            controlNew.data.writepos = (controlNew.data.writepos + controlNew.data.active) % (buffer->size);
            controlNew.data.active = 0;
            controlNew.data.ready = 0;
        }
    } while (Ifx_DebugPipe_CompareAndSet(&buffer->control.value, controlOld.value, controlNew.value) == FALSE);
    return TRUE;
}

boolean Ifx_DebugPipe_FifoRead(volatile Ifx_DebugPipeBuffer * buffer, char * dst, uint8 * count) {
    Ifx_DebugPipeBufferControl controlNew;
    Ifx_DebugPipeBufferControl controlOld;

    controlOld = buffer->control;
    uint8 read = 0;
    uint8 toread = *count;

    if (controlOld.data.writepos == controlOld.data.readpos) {
        // buffer empty
        return FALSE;
    }

    /* copy data */
    uint8 i = controlOld.data.readpos;
    do {
        *dst = buffer->data[i];
        dst++;
        read++;
        i = (i + 1) % buffer->size;
        toread--;
    } while ((i != controlOld.data.writepos) && (toread > 0));

    /* update circular buffer */
    do {
        controlOld = buffer->control;
        controlNew = controlOld;
        controlNew.data.readpos = (controlNew.data.readpos + read) % (buffer->size);

    } while (Ifx_DebugPipe_CompareAndSet(&buffer->control.value, controlOld.value, controlNew.value) == FALSE);

    *count = read;
    return TRUE;
}

boolean Ifx_DebugPipe_Write(Ifx_DebugPipe * dPipe, void *data, Ifx_SizeT *count, Ifx_TickTime timeout) {

    while (Ifx_DebugPipe_FifoWrite(&dPipe->tx, data, *count) == FALSE) {
    }
    dPipe->writeCount += *count;
    return TRUE;
}

boolean Ifx_DebugPipe_Read(Ifx_DebugPipe * dPipe, void *data, Ifx_SizeT *count, Ifx_TickTime timeout) {

    uint8 read;
    if (Ifx_DebugPipe_FifoRead(&dPipe->rx, data, &read)) {
        dPipe->readCount += read;
        *count = read;
        return TRUE;
    } else {
        *count = 0;
        return FALSE;
    }
}

sint32 Ifx_DebugPipe_GetReadCount(Ifx_DebugPipe * dPipe) {
    return Ifx_DebugPipe_FifoDist(dPipe->rx.control.data.writepos, dPipe->rx.control.data.readpos, dPipe->rx.size);
}

sint32 Ifx_DebugPipe_GetWriteCount(Ifx_DebugPipe * dPipe) {
    return Ifx_DebugPipe_FifoDist(dPipe->tx.control.data.writepos, dPipe->tx.control.data.readpos, dPipe->tx.size);
}

uint32 Ifx_DebugPipe_GetSendCount(Ifx_DebugPipe * dPipe) {
    return 0;
}

Ifx_TickTime Ifx_DebugPipe_GetTxTimeStamp(Ifx_DebugPipe * dPipe) {
    return 0;
}

boolean Ifx_DebugPipe_CanReadCount(Ifx_DebugPipe * dPipe, Ifx_SizeT count, Ifx_TickTime timeout) {
    return Ifx_DebugPipe_GetReadCount(dPipe) >= count;
}

boolean Ifx_DebugPipe_CanWriteCount(Ifx_DebugPipe * dPipe, Ifx_SizeT count, Ifx_TickTime timeout) {
    return (dPipe->tx.size - Ifx_DebugPipe_GetWriteCount(dPipe)) >= count;
}

boolean Ifx_DebugPipe_FlushTx(Ifx_DebugPipe * dPipe, Ifx_TickTime timeout) {
    return TRUE;
}

void Ifx_DebugPipe_ClearRx(Ifx_DebugPipe * dPipe) {
}

void Ifx_DebugPipe_ClearTx(Ifx_DebugPipe * dPipe) {
}


void Ifx_DebugPipe_OnReceive(Ifx_DebugPipe * dPipe) {

}

void Ifx_DebugPipe_OnTransmit(Ifx_DebugPipe * dPipe) {

}

void Ifx_DebugPipe_OnError(Ifx_DebugPipe * dPipe) {
    dPipe->isError = TRUE;
}

void Ifx_DebugPipe_ResetSendCount(Ifx_DebugPipe * dPipe) {
    dPipe->writeCount = 0;
}

boolean Ifx_DebugPipe_stdIfDPipeInit(IfxStdIf_DPipe *stdif, Ifx_DebugPipe *dpipe) {
    /* Ensure the stdif is reset to zeros */
    memset(stdif, 0, sizeof(IfxStdIf_DPipe));

    /* Set the API link */
    stdif->driver = (IfxStdIf_InterfaceDriver) dpipe;
    stdif->write = (IfxStdIf_DPipe_Write) &Ifx_DebugPipe_Write;
    stdif->read = (IfxStdIf_DPipe_Read) &Ifx_DebugPipe_Read;
    stdif->getReadCount = (IfxStdIf_DPipe_GetReadCount) &Ifx_DebugPipe_GetReadCount;
    stdif->getReadEvent = (IfxStdIf_DPipe_GetReadEvent) NULL_PTR;
    stdif->getWriteCount = (IfxStdIf_DPipe_GetWriteCount) &Ifx_DebugPipe_GetWriteCount;
    stdif->getWriteEvent = (IfxStdIf_DPipe_GetWriteEvent) NULL_PTR;
    stdif->canReadCount = (IfxStdIf_DPipe_CanReadCount) &Ifx_DebugPipe_CanReadCount;
    stdif->canWriteCount = (IfxStdIf_DPipe_CanWriteCount) &Ifx_DebugPipe_CanWriteCount;
    stdif->flushTx = (IfxStdIf_DPipe_FlushTx) &Ifx_DebugPipe_FlushTx;
    stdif->clearTx = (IfxStdIf_DPipe_ClearTx) &Ifx_DebugPipe_ClearTx;
    stdif->clearRx = (IfxStdIf_DPipe_ClearRx) &Ifx_DebugPipe_ClearRx;
    stdif->onReceive = (IfxStdIf_DPipe_OnReceive) &Ifx_DebugPipe_OnReceive;
    stdif->onTransmit = (IfxStdIf_DPipe_OnTransmit) &Ifx_DebugPipe_OnTransmit;
    stdif->onError = (IfxStdIf_DPipe_OnError) &Ifx_DebugPipe_OnError;
    stdif->getSendCount = (IfxStdIf_DPipe_GetSendCount) &Ifx_DebugPipe_GetSendCount;
    stdif->getTxTimeStamp = (IfxStdIf_DPipe_GetTxTimeStamp) &Ifx_DebugPipe_GetTxTimeStamp;
    stdif->resetSendCount = (IfxStdIf_DPipe_ResetSendCount) &Ifx_DebugPipe_ResetSendCount;
    stdif->txDisabled = FALSE;
    return TRUE;
}

boolean Ifx_DebugPipe_Init(Ifx_DebugPipe * dpipe, Ifx_DebugPipeConfig * config) {
    dpipe->rx.data = malloc(config->size);
    dpipe->tx.data = malloc(config->size);
    dpipe->rx.size = config->size;
    dpipe->tx.size = config->size;

    if ((dpipe->rx.data == NULL_PTR) || (dpipe->tx.data == NULL_PTR)) {
        dpipe->isError = TRUE;
        free(dpipe->rx.data);
        free(dpipe->tx.data);
        return FALSE;
    }
    return TRUE;
}
