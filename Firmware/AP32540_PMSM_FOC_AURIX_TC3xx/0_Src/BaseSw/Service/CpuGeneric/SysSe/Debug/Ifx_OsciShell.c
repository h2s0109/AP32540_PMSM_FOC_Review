/**
 * \file Ifx_OsciShell.c
 * \brief Osci shell
 *
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *                            IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#include "Ifx_OsciShell.h"

#define BOOLEAN_STR(v) (((v) != FALSE) ? "TRUE" : "FALSE")

static boolean Ifx_OsciShell_run(pchar arguments, void* data, IfxStdIf_DPipe* io);
static boolean Ifx_OsciShell_stop(pchar arguments, void* data, IfxStdIf_DPipe* io);
static boolean Ifx_OsciShell_trigger(pchar arguments, void* data, IfxStdIf_DPipe* io);
static boolean Ifx_OsciShell_status(pchar arguments, void* data, IfxStdIf_DPipe* io);
static boolean Ifx_OsciShell_channel(pchar arguments, void* data, IfxStdIf_DPipe* io);
static boolean Ifx_OsciShell_analyze(pchar arguments, void* data, IfxStdIf_DPipe* io);
#if 0
static boolean Ifx_OsciShell_simulate(pchar arguments, void* data, IfxStdIf_DPipe* io);
#endif
static boolean Ifx_OsciShell_dump(pchar arguments, void* data, IfxStdIf_DPipe* io);

/* *INDENT-OFF* */
Ifx_Shell_Command Ifx_g_OsciShell_commands[] =
{
    {IFX_OSCI_SHELL_PREFIX, "     : Oscilloscope functions"            , NULL_PTR, NULL_PTR               },
    {"start", "      : start the oscilloscope"ENDL
        "/s start [auto|normal] [single]"
            , NULL_PTR, &Ifx_OsciShell_run     },
    {"stop", "     : stop the oscilloscope"
            , NULL_PTR, &Ifx_OsciShell_stop    },
    {"trigger", "  : trigger settings"ENDL
        "/s trigger [force] [auto|normal|inverted] [single] [level <value>] [rising|falling] [source <chNum>] [interval <value>] [arm]"ENDL
            "/p force: Force the trigger"ENDL
            "/p [auto|normal|inverted]: trigger mode auto, normal (trigger starts the sampling) or inverted (trigger stops the sampling)"ENDL
            "/p single: toggles single trigger"ENDL
            "/p level <value>: Set trigger level to value"ENDL
            "/p [rising|falling]: Set trigger to raising or falling edges"ENDL
            "/p source <chNum>: Set trigger channel number"ENDL
            "<chNum> can be obtained with 'channel' command"ENDL
            "/p interval <value>: Set sampling interval to value"ENDL
            "/p arm: re-arm the trigger"
            , NULL_PTR, &Ifx_OsciShell_trigger },
    {"status", "   : display status"
            , NULL_PTR, &Ifx_OsciShell_status  },
    {"channel", "  : channel information"ENDL
            "/s channel: Show the channels information"ENDL
            "/s channel clear <ch>: clears the channel"ENDL
            "/s channel <sig> <ch>: Assign a signal to a channel"
            , NULL_PTR, &Ifx_OsciShell_channel },
    {"analyze", "  : signal analysis of a ch"ENDL
        "/s analyze <ch>: analyze the input channel <ch>"
            , NULL_PTR, &Ifx_OsciShell_analyze },
#if 0
    {"simulate", " : simulate a signal"ENDL
        "/s simulate <ch> <op> <wave> <freq> <ampl> <offs> <phase> : Simulate a signal generation"ENDL
            "/p <ch>   : {0 .. Channel count}"ENDL
            "/p <op>   : {add,sub,mul,clr}"ENDL
            "/p <wave> : {sine,square}"ENDL
            "/p <freq> : -INF .. INF"ENDL
            "/p <offs> : -INF .. INF"ENDL
            "/p <ampl> : -INF .. INF"ENDL
            "/p <phase>: 0 .. 360 [degree]"ENDL
        "/s simulate <ch> atan <ych> <xch>: Compute atan(ych/xch) and store in channel <ch>"
            , NULL_PTR, &Ifx_OsciShell_simulate},
#endif
    {"dump", "     : dump values (all channels)"ENDL
        "/s dump <ch> [hex]"ENDL
            "/p <ch>: Dump the values of the channel <ch>"ENDL
            "/p hex: If hex is specified, values will be in hexadecimal"
            , NULL_PTR, &Ifx_OsciShell_dump    },
    IFX_SHELL_COMMAND_LIST_END,
};
/* *INDENT-ON* */

static pchar Ifx_OsciShell_stateToStr(Ifx_Osci_TriggerState state)
{
    switch (state)
    {
    case Ifx_Osci_TriggerState_arm:
        return "arm";
    case Ifx_Osci_TriggerState_armed:
        return "armed";
    case Ifx_Osci_TriggerState_stopped:
        return "stopped";
    case Ifx_Osci_TriggerState_triggered:
        return "triggered";
    }

    return "error";
}


static boolean Ifx_OsciShell_run(pchar arguments, void* data, IfxStdIf_DPipe* io)
{
    Ifx_OsciShell* osciShell;
    osciShell = (Ifx_OsciShell*)data;
    Ifx_Osci* osci = osciShell->osci;

    if (Ifx_Shell_matchToken(&arguments, "auto") != FALSE)
    {
        Ifx_Osci_setTriggerMode(osci, Ifx_Osci_TriggerMode_automatic);
    }

    if (Ifx_Shell_matchToken(&arguments, "normal") != FALSE)
    {
        Ifx_Osci_setTriggerMode(osci, Ifx_Osci_TriggerMode_normal);
    }

    if (Ifx_Shell_matchToken(&arguments, "single") != FALSE)
    {
        Ifx_Osci_setTriggerSingle(osci, TRUE);
    }

    Ifx_Osci_start(osci);
    IfxStdIf_DPipe_print(io, "Osci started"ENDL);
    Ifx_OsciShell_status("", data, io);
    return TRUE;
}


static boolean Ifx_OsciShell_trigger(pchar arguments, void* data, IfxStdIf_DPipe* io)
{
    Ifx_OsciShell* osciShell;
    osciShell = (Ifx_OsciShell*)data;
    Ifx_Osci* osci = osciShell->osci;

    if (Ifx_Shell_matchToken(&arguments, "force") != FALSE)
    {
        Ifx_Osci_start(osci);
        Ifx_Osci_forceTrigger(osci);
        IfxStdIf_DPipe_print(io, "Trigger forced"ENDL);
        return TRUE;
    }

    if (Ifx_Shell_matchToken(&arguments, "auto") != FALSE)
    {
        Ifx_Osci_setTriggerMode(osci, Ifx_Osci_TriggerMode_automatic);
    }

    if (Ifx_Shell_matchToken(&arguments, "normal") != FALSE)
    {
        Ifx_Osci_setTriggerMode(osci, Ifx_Osci_TriggerMode_normal);
    }

    if (Ifx_Shell_matchToken(&arguments, "inverted") != FALSE)
    {
        Ifx_Osci_setTriggerMode(osci, Ifx_Osci_TriggerMode_inverted);
    }

    if (Ifx_Shell_matchToken(&arguments, "single") != FALSE)
    {
        Ifx_Osci_setTriggerSingle(osci, !osci->trigger.single);
        IfxStdIf_DPipe_print(io, "Trigger single set to %s"ENDL, BOOLEAN_STR(osci->trigger.single));
    }

    if (Ifx_Shell_matchToken(&arguments, "level") != FALSE)
    {
        float32 level;

        if (Ifx_Shell_parseFloat32(&arguments, &level) != FALSE)
        {
            Ifx_Osci_setTriggerLevel(osci, level);
        }
    }

    if (Ifx_Shell_matchToken(&arguments, "rising") != FALSE)
    {
        Ifx_Osci_setTriggerEdge(osci, Ifx_Osci_TriggerEdge_rising);
    }

    if (Ifx_Shell_matchToken(&arguments, "falling") != FALSE)
    {
        Ifx_Osci_setTriggerEdge(osci, Ifx_Osci_TriggerEdge_falling);
    }

    if (Ifx_Shell_matchToken(&arguments, "source") != FALSE)
    {
        uint32 source;

        if (Ifx_Shell_parseUInt32(&arguments, &source, FALSE) != FALSE)
        {
            Ifx_Osci_setTriggerSource(osci, source);
        }
    }

    if (Ifx_Shell_matchToken(&arguments, "interval") != FALSE)
    {
        sint32 interval;

        if (Ifx_Shell_parseSInt32(&arguments, &interval) != FALSE)
        {
            Ifx_Osci_setSamplingInterval(osci, (uint16)interval);
        }
    }

    if (Ifx_Shell_matchToken(&arguments, "arm") != FALSE)
    {
        Ifx_Osci_start(osci);
        Ifx_Osci_armTrigger(osci);
    }

    Ifx_OsciShell_status(arguments, data, io);

    return TRUE;
}


boolean Ifx_OsciShell_init(Ifx_OsciShell* osciShell, Ifx_OsciShell_Config* config)
{
    uint32 index;

    index           = 0;
    osciShell->osci = config->osci;

    while (Ifx_g_OsciShell_commands[index].commandLine != NULL_PTR)
    {
        Ifx_g_OsciShell_commands[index].data = osciShell;
        index++;
    }

    return TRUE;
}


void Ifx_OsciShell_initConfig(Ifx_OsciShell_Config* config, Ifx_Osci* osci)
{
    config->osci = osci;
}


static boolean Ifx_OsciShell_stop(pchar arguments, void* data, IfxStdIf_DPipe* io)
{
    Ifx_OsciShell* osciShell;
    osciShell = (Ifx_OsciShell*)data;
    Ifx_Osci* osci = osciShell->osci;

    Ifx_Osci_stop(osci);
    IfxStdIf_DPipe_print(io, "Osci stopped"ENDL);
    return TRUE;
}


static boolean Ifx_OsciShell_analyze(pchar arguments, void* data, IfxStdIf_DPipe* io)
{
    Ifx_OsciShell* osciShell;
    osciShell = (Ifx_OsciShell*)data;
    Ifx_Osci* osci = osciShell->osci;

    uint32 chnr;

    if ((Ifx_Shell_parseUInt32(&arguments, &chnr, FALSE) != FALSE) && (chnr < osci->maxNumOfChannels))
    {
        IfxStdIf_DPipe_print(io, "Analyzing channel %d"ENDL, chnr);

        osci->fft.source  = chnr;
        osci->fft.enabled = TRUE;
        Ifx_Osci_analyze(osci);

        if (osci->fft.enabled)
        {
            /* Report results */
            IfxStdIf_DPipe_print(io, " * Signal peak = %f dB at %f Hz"ENDL,        osci->fft.result.pPeak, osci->fft.result.fPeak);
            IfxStdIf_DPipe_print(io, " * Signal + Noise + Distortion = %f dB"ENDL, osci->fft.result.pTot);
            IfxStdIf_DPipe_print(io, " * Noise + Distortion = %f dB"ENDL,          osci->fft.result.pnd);
            IfxStdIf_DPipe_print(io, " * SINAD = %f dB"ENDL,                       osci->fft.result.sinad);
            IfxStdIf_DPipe_print(io, " * ENOB = %f bits"ENDL,                      osci->fft.result.enob);
        }
    }
    else
    {
        IfxStdIf_DPipe_print(io, "ERROR: channel number is out of range"ENDL);
    }

    return TRUE;
}


static boolean Ifx_OsciShell_channel(pchar arguments, void* data, IfxStdIf_DPipe* io)
{
    Ifx_OsciShell* osciShell;
    osciShell = (Ifx_OsciShell*)data;
    Ifx_Osci* osci = osciShell->osci;

    sint16 i;

    sint32 channel, isignal;

    if (Ifx_Shell_matchToken(&arguments, "clear") != FALSE)
    {
        if (Ifx_Shell_parseSInt32(&arguments, &channel) != FALSE)
        {
            osci->channels[channel].signal = NULL_PTR;
            IfxStdIf_DPipe_print(io, "Channel %d has been cleared"ENDL, channel);
        }

        return TRUE;
    }

    if (Ifx_Shell_parseSInt32(&arguments, &isignal) != FALSE)
    {
        if (channel < osci->maxNumOfSignals)
        {
            if (Ifx_Shell_parseSInt32(&arguments, &channel) != FALSE)
            {
                if (Ifx_Osci_associateSignalToChannel(osci, (sint16)isignal, (sint16)channel) != FALSE)
                {
                    IfxStdIf_DPipe_print(io, "Signal %d(%s) has been assigned to channel %d"ENDL, isignal, osci->signalList[isignal].name, channel);
                }
                else
                {
                    IfxStdIf_DPipe_print(io, "ERROR: signal number is unknown"ENDL);
                }
            }
            else
            {
                IfxStdIf_DPipe_print(io, "ERROR: please provide signal number"ENDL);
            }
        }
        else
        {
            IfxStdIf_DPipe_print(io, "ERROR: channel number is out of range"ENDL);
        }
    }
    else
    {
        IfxStdIf_DPipe_print(io, "Available channels:"ENDL);

        for (i = 0; i < osci->maxNumOfChannels; i++)
        {
            const Ifx_Osci_Channel* channel = &osci->channels[i];
            IfxStdIf_DPipe_print(io, "Channel %d:", i);

            if (channel->signal == NULL_PTR)
            {
                IfxStdIf_DPipe_print(io, "No signal selected");
            }
            else
            {
                IfxStdIf_DPipe_print(io, "Signal %d(%s), type (%s)"ENDL, channel->signal->id, channel->signal->name, Ifx_Osci_getDataTypeName(channel->signal->type));
            }
        }

        IfxStdIf_DPipe_print(io, ENDL "Available signals:"ENDL);

        for (i = 0; i < osci->usedSignals; i++)
        {
            IfxStdIf_DPipe_print(io, "Signal %2d: %s"ENDL, osci->signalList[i].id, osci->signalList[i].name);
        }
    }

    return TRUE;
}


#if 0
static boolean Ifx_OsciShell_simulate(pchar arguments, void* data, IfxStdIf_DPipe* io)
{
    Ifx_OsciShell* osciShell;
    osciShell = (Ifx_OsciShell*)data;
    Ifx_Osci* osci = osciShell->osci;

    sint32              chnr;
    float32             freq, ampl, offset, phase;
    Ifx_Osci_Operation  op;
    Ifx_Osci_SignalType type;

    /* first argument is oscilloscope channel number */
    Ifx_Shell_parseSInt32(&arguments, &chnr);

    /* second argument is [add,sub,mul] which indicates signal operation */
    if (Ifx_Shell_matchToken(&arguments, "atan") != FALSE)
    {
        sint32 ych, xch;

        if (Ifx_Shell_parseSInt32(&arguments, &ych) == FALSE)
        {
            ych = 1;
        }

        if (Ifx_Shell_parseSInt32(&arguments, &xch) == FALSE)
        {
            xch = 0;
        }

        Ifx_Osci_doChannelOperation(&osci->channels[chnr], &osci->channels[xch], Ifx_Osci_Operation_atan2, &osci->channels[ych]);
    }
    else
    {
        if (Ifx_Shell_matchToken(&arguments, "add") != FALSE)
        {
            op = Ifx_Osci_Operation_add;
        }
        else if (Ifx_Shell_matchToken(&arguments, "sub") != FALSE)
        {
            op = Ifx_Osci_Operation_sub;
        }
        else if (Ifx_Shell_matchToken(&arguments, "mul") != FALSE)
        {
            op = Ifx_Osci_Operation_mul;
        }
        else if (Ifx_Shell_matchToken(&arguments, "div") != FALSE)
        {
            op = Ifx_Osci_Operation_div;
        }
        else if (Ifx_Shell_matchToken(&arguments, "clr") != FALSE)
        {
            op = Ifx_Osci_Operation_clr;
        }
        else if (Ifx_Shell_matchToken(&arguments, "set") != FALSE)
        {
            op = Ifx_Osci_Operation_set;
        }
        else
        {
            op = Ifx_Osci_Operation_clr;
        }

        /* third argument is [sine,square] which indicates the signal type */
        if (Ifx_Shell_matchToken(&arguments, "sine") != FALSE)
        {
            type = Ifx_Osci_SignalType_sine;
        }
        else if (Ifx_Shell_matchToken(&arguments, "square") != FALSE)
        {
            type = Ifx_Osci_SignalType_square;
        }
        else
        {
            type = Ifx_Osci_SignalType_sine;
        }

        /* last arguments are <freq> <ampl> <offs> which are amplitude and frequency */
        if (Ifx_Shell_parseFloat32(&arguments, &freq) == FALSE)
        {
            freq = 1.0;
        }

        if (Ifx_Shell_parseFloat32(&arguments, &ampl) == FALSE)
        {
            ampl = 1.0;
        }

        if (Ifx_Shell_parseFloat32(&arguments, &offset) == FALSE)
        {
            offset = 0.0;
        }

        if (Ifx_Shell_parseFloat32(&arguments, &phase) == FALSE)
        {
            phase = 0.0;
        }

        chnr = __max(__min(chnr, osci->channelCount - 1), 0);
        {
            Ifx_Osci_doSignalOperation(&osci->channels[chnr], &osci->channels[chnr], op, type, freq, ampl, offset, phase);
        }
    }

    return TRUE;
}


#endif

static boolean Ifx_OsciShell_dump(pchar arguments, void* data, IfxStdIf_DPipe* io)
{
    Ifx_OsciShell* osciShell;
    osciShell = (Ifx_OsciShell*)data;
    Ifx_Osci* osci = osciShell->osci;

    boolean result = TRUE;
    float32 values[osci->maxNumOfChannels];
    sint32  startCh = 0, endCh = osci->maxNumOfChannels - 1;

    boolean hexMode  = Ifx_Shell_matchToken(&arguments, "hex");
    boolean fastMode = Ifx_Shell_matchToken(&arguments, "fast");

    if (Ifx_Shell_parseSInt32(&arguments, &startCh) != FALSE)
    {
        result = (startCh < osci->maxNumOfChannels) ? TRUE : FALSE;
        endCh  = startCh;
    }

    if (osci->enabled == TRUE)
    {
        Ifx_Osci_stop(osci);
        IfxStdIf_DPipe_print(io, "Oscilloscope has been stopped."ENDL);
    }

    if (osci->readIndex == osci->writeIndex)
    {
        IfxStdIf_DPipe_print(io, "There is no available data to dump; please run the oscilloscope.");
    }

    if (result != FALSE)
    {
        sint32 i;

        for (i = startCh; i < endCh; i++)
        {
            if (osci->channels[i].signal != NULL_PTR)
            {
                IfxStdIf_DPipe_print(io, "%s\t", osci->channels[i].signal->name);
            }
        }

        IfxStdIf_DPipe_print(io, ENDL);
        uint32 checksum = 0;

        while (Ifx_Osci_getNextData(osci, values) != FALSE)
        {
            for (i = startCh; i <= endCh; i++) //i <= endCh so that dump a specific channel works. if no channel is specified then endCh=maxNumOfChannels-1
            {
                if (osci->channels[i].signal == NULL_PTR)
                {
                    continue;
                }

                uint32 asInteger = (*((uint32*)&(values[i])));

                if (hexMode)
                {
                    IfxStdIf_DPipe_print(io, "%08X\t", asInteger);
                }
                else
                {
                    if (!fastMode)
                    {
                        IfxStdIf_DPipe_print(io, "%e\t", values[i]);
                    }
                    else
                    {
                        IfxStdIf_DPipe_print(io, "%2.2f\t", values[i]);
                    }
                }

                checksum = checksum + asInteger;
            }

            wait(TimeConst_1ms * 4);

            IfxStdIf_DPipe_print(io, ENDL);
            i++;

            if (i > osci->dataLength)
            {
                IfxStdIf_DPipe_print(io, "Overflow error"ENDL);
                break;
            }
        }

        /* increment read data so that it's possible to make multiple dumps of the same data set (use case: multiple dumps of single channels) */
        osci->readIndex++;

        if (hexMode)
        {
            IfxStdIf_DPipe_print(io, "Checksum = %08X"ENDL, checksum);
        }
    }
    else
    {
        IfxStdIf_DPipe_print(io, "ERROR: invalid channel number %d, range is 0 .. %d", startCh, osci->maxNumOfChannels - 1);
    }

    return TRUE;
}


static boolean Ifx_OsciShell_status(pchar arguments, void* data, IfxStdIf_DPipe* io)
{
    Ifx_OsciShell* osciShell;
    osciShell = (Ifx_OsciShell*)data;
    Ifx_Osci* osci = osciShell->osci;

    IfxStdIf_DPipe_print(io, " * Sampling freq: %f Hz"ENDL, (1.0 / osci->samplePeriod));
    IfxStdIf_DPipe_print(io, " * Enabled: %s"ENDL,          BOOLEAN_STR(osci->enabled));

    IfxStdIf_DPipe_print(io, "Trigger settings:"ENDL);
    pchar mode = (osci->trigger.mode == Ifx_Osci_TriggerMode_automatic ? "Auto" : osci->trigger.mode == Ifx_Osci_TriggerMode_normal ? "Normal" : "Inverted");
    IfxStdIf_DPipe_print(io, " * source: %d (%s)"ENDL, osci->trigger.source, osci->channels[osci->trigger.source].signal->name);
    IfxStdIf_DPipe_print(io, " * mode: %s"ENDL,        mode);
    IfxStdIf_DPipe_print(io, " * single: %s"ENDL,      BOOLEAN_STR(osci->trigger.single));
    IfxStdIf_DPipe_print(io, " * edge: %s"ENDL,        (osci->trigger.edge == Ifx_Osci_TriggerEdge_rising ? "Rising" : "Falling"));
    IfxStdIf_DPipe_print(io, " * level: %f"ENDL,       osci->trigger.level);
    IfxStdIf_DPipe_print(io, " * interval: %d"ENDL,    osci->samplingInterval);
    IfxStdIf_DPipe_print(io, " * state: %s"ENDL,       Ifx_OsciShell_stateToStr(osci->trigger.state));

    return TRUE;
}
