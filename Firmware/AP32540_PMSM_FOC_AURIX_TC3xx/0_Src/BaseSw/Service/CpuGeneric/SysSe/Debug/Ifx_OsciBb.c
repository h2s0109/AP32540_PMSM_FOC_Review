/*
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *                            IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#include  "Ifx_OsciBb.h"
#include  "Ifx_OsciBbMessages.h"
#include <string.h>

static boolean Ifx_Osci_sendOscilloscopeState(Ifx_OsciBb* bb);
static boolean Ifx_Osci_sendOscilloscopeSignalInfo(Ifx_OsciBb* bb, Ifx_Osci_SignalId signalId);
static boolean Ifx_Osci_sendOscilloscopeChannelInfo(Ifx_OsciBb* bb, Ifx_Osci_ChannelId channelId);
static void    Ifx_Osci_sendOscilloscopeSendChannelsData(Ifx_OsciBb* bb);

boolean        Ifx_OsciBb_init(Ifx_OsciBb* bb, Ifx_Osci* osci, SyncProtocol* protocol, SyncProtocol_Port localPort, SyncProtocol_Port remotePort)
{
    bb->_osci                  = osci;
    bb->_osciChannelDataOffset = 0;
    bb->_OsciChannelId         = 0;
    bb->_osciSingle            = TRUE;
    bb->_osciStateSend         = FALSE;
    bb->_osciSignalInfoSend    = 0;
    bb->_osciChannelInfoSend   = 0;

    return SyncProtocol_addClient(protocol, &bb->_bbClient, localPort, remotePort, bb->_bbClientMessagePayloadRx, sizeof(bb->_bbClientMessagePayloadRx));
}


static boolean Ifx_Osci_sendOscilloscopeState(Ifx_OsciBb* bb)
{
    if (SyncProtocol_setSendMessageBuffer(
            &bb->_bbClient,
            SYNCPROTOCOL_MESSAGE_ID_OSCILLOSCOPE_STATE,
            bb->_bbClientMessagePayloadTx,
            sizeof(Oscilloscope_MessageState)))
    {
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, sizeof(bb->_bbClientMessagePayloadTx) >= sizeof(Oscilloscope_MessageState));

        Oscilloscope_MessageState* m = (Oscilloscope_MessageState*)bb->_bbClientMessagePayloadTx;
        m->triggerLevel        = Ifx_Osci_getTriggerLevel(bb->_osci);
        m->samplingPeriod      = Ifx_Osci_getSamplingPeriod(bb->_osci);
        m->flags.enabled       = Ifx_Osci_isRunning(bb->_osci) ? 1 : 0;
        m->flags.triggerSingle = bb->_osciSingle ? 1 : 0;

        switch (Ifx_Osci_getTriggerMode(bb->_osci))
        {
        case Ifx_Osci_TriggerMode_normal:
            m->flags.triggerMode = 0;
            break;
        case Ifx_Osci_TriggerMode_automatic:
            m->flags.triggerMode = 1;
            break;
        case Ifx_Osci_TriggerMode_inverted:
            m->flags.triggerMode = 2;
            break;
        }

        switch (Ifx_Osci_getTriggerEdge(bb->_osci))
        {
        case Ifx_Osci_TriggerEdge_falling:
            m->flags.triggerEdge = 0;
            break;
        case Ifx_Osci_TriggerEdge_rising:
            m->flags.triggerEdge = 1;
            break;
        }

        m->flags.reserved   = 0;
        m->samplingInterval = Ifx_Osci_getSamplingInterval(bb->_osci);
        m->triggerChannel   = Ifx_Osci_getTriggerSource(bb->_osci);
        m->numberOfChannels = Ifx_Osci_getNumberOfChannels(bb->_osci);
        m->numberOfSignals  = Ifx_Osci_getUsedSignals(bb->_osci);
        m->maxDepth         = Ifx_Osci_getMaxDepth();
        m->depth            = Ifx_Osci_getDepth(bb->_osci);
        SyncProtocol_sendMessage(&bb->_bbClient);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


static boolean Ifx_Osci_sendOscilloscopeSignalInfo(Ifx_OsciBb* bb, Ifx_Osci_SignalId signalId)
{
    Ifx_Osci_Signal*                info = Ifx_Osci_getSignalInfo(bb->_osci, signalId);
    Oscilloscope_MessageSignalInfo* m    = (Oscilloscope_MessageSignalInfo*)bb->_bbClientMessagePayloadTx;

    if (info != NULL)
    {
        if (SyncProtocol_setSendMessageBuffer(
                &bb->_bbClient,
                SYNCPROTOCOL_MESSAGE_ID_OSCILLOSCOPE_SIGNAL_INFO,
                bb->_bbClientMessagePayloadTx,
                16 + strlen(info->name) + 1))
        {
            IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, sizeof(bb->_bbClientMessagePayloadTx) >= sizeof(Oscilloscope_MessageSignalInfo));
            IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, strlen(info->name) < sizeof(m->name));

            m->signalId    = signalId;
            m->reserved[0] = 0;
            m->reserved[1] = 0;
            m->reserved[2] = 0;
            m->reserved[4] = 0;
            m->reserved[5] = 0;
            m->reserved[6] = 0;
            strcpy((char*)m->name, info->name);
            SyncProtocol_sendMessage(&bb->_bbClient);
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return TRUE;
    }
}


static boolean Ifx_Osci_sendOscilloscopeChannelInfo(Ifx_OsciBb* bb, Ifx_Osci_ChannelId channelId)
{
    Oscilloscope_MessageAssignedChannel* m = (Oscilloscope_MessageAssignedChannel*)bb->_bbClientMessagePayloadTx;

    if (SyncProtocol_setSendMessageBuffer(
            &bb->_bbClient,
            SYNCPROTOCOL_MESSAGE_ID_OSCILLOSCOPE_ASSIGNED_CHANNEL,
            bb->_bbClientMessagePayloadTx,
            sizeof(Oscilloscope_MessageAssignedChannel)))
    {
        m->channelId = channelId;
        m->signalId  = Ifx_Osci_getChannelSignal(bb->_osci, channelId);
        m->dataDepth = Ifx_Osci_getDepth(bb->_osci);
        SyncProtocol_sendMessage(&bb->_bbClient);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


static void Ifx_Osci_sendOscilloscopeSendChannelsData(Ifx_OsciBb* bb)
{
    uint8 newData = 0;

    if (SyncProtocol_isSendBusy(&bb->_bbClient))
    {
        return;
    }

    if (!bb->_osciStateSend)
    {
        bb->_osciStateSend = Ifx_Osci_sendOscilloscopeState(bb);
    }
    else if (bb->_osciSignalInfoSend < Ifx_Osci_getUsedSignals(bb->_osci))
    {
        if (Ifx_Osci_sendOscilloscopeSignalInfo(bb, bb->_osciSignalInfoSend))
        {
            bb->_osciSignalInfoSend++;
        }
    }
    else if (bb->_osciChannelInfoSend < Ifx_Osci_getNumberOfChannels(bb->_osci))
    {
        if (Ifx_Osci_sendOscilloscopeChannelInfo(bb, bb->_osciChannelInfoSend))
        {
            bb->_osciChannelInfoSend++;
        }
    }
    else if (!Ifx_Osci_isRunning(bb->_osci) || (Ifx_Osci_getTriggerState(bb->_osci) != Ifx_Osci_TriggerState_stopped))
    {
        return;
    }
    else
    {
        if ((bb->_OsciChannelId == 0) && (bb->_osciChannelDataOffset == 0))
        {
            /* Wait for new data */
            while ((bb->_OsciChannelId < Ifx_Osci_getNumberOfChannels(bb->_osci)) && (Ifx_Osci_getChannelSignal(bb->_osci, bb->_OsciChannelId) == IFX_OSCI_NO_SIGNAL))
            {
                bb->_OsciChannelId++;
            }

            newData = 1;
        }

        if (bb->_OsciChannelId < Ifx_Osci_getNumberOfChannels(bb->_osci))
        {
            Oscilloscope_MessageChannelData* m = (Oscilloscope_MessageChannelData*)bb->_bbClientMessagePayloadTx;

            if (SyncProtocol_setSendMessageBuffer(
                    &bb->_bbClient,
                    SYNCPROTOCOL_MESSAGE_ID_OSCILLOSCOPE_CHANNEL_DATA,
                    bb->_bbClientMessagePayloadTx,
                    sizeof(Oscilloscope_MessageChannelData)))
            {
                uint16   index;
                uint16   length;
                float32* data;
                length = Ifx_Osci_getDepth(bb->_osci) - bb->_osciChannelDataOffset;
                length = length > SYNCPROTOCOL_MESSAGE_ID_OSCILLOSCOPE_CHANNEL_DATA_MAX_PAYLOAD
                         ? SYNCPROTOCOL_MESSAGE_ID_OSCILLOSCOPE_CHANNEL_DATA_MAX_PAYLOAD
                         : length;

                m->channelId                = bb->_OsciChannelId;
                m->signalId                 = Ifx_Osci_getChannelSignal(bb->_osci, bb->_OsciChannelId);
                m->flags.dataLength         = length;
                m->flags.newData            = newData;
                m->flags.reserved           = 0;
                m->reserved                 = 0;
                m->dataOffset               = bb->_osciChannelDataOffset;
                bb->_osciChannelDataOffset += length;

                data                        = Ifx_Osci_getChannelDataPointer(bb->_osci, m->channelId);

                for (index = 0; index < m->flags.dataLength; index++)
                {
                    m->data[index] = data[m->dataOffset + index];
                }

                SyncProtocol_sendMessage(&bb->_bbClient);

                if (bb->_osciChannelDataOffset == Ifx_Osci_getDepth(bb->_osci))
                {
                    bb->_osciChannelDataOffset = 0;
                    bb->_OsciChannelId++;

                    while ((bb->_OsciChannelId < Ifx_Osci_getNumberOfChannels(bb->_osci)) && (Ifx_Osci_getChannelSignal(bb->_osci, bb->_OsciChannelId) == IFX_OSCI_NO_SIGNAL))
                    {
                        bb->_OsciChannelId++;
                    }

                    if (!bb->_osciSingle && (bb->_OsciChannelId >= Ifx_Osci_getNumberOfChannels(bb->_osci)))
                    {
                        /* Automatically restart */
                        Ifx_Osci_armTrigger(bb->_osci);
                        bb->_OsciChannelId = 0;
                    }
                }
            }
        }
    }
}


void Ifx_OsciBb_processMessages(Ifx_OsciBb* bb)
{
    if (bb->_osci == NULL)
    {   /* BB un-initialized */
        return;
    }

    if (bb->_bbClient.receive.messageValid)
    {
        SyncProtocol_MessageId id;
        uint32                 length;
        uint8*                 payloadRx;

        if (SyncProtocol_getReadMessageBuffer(&bb->_bbClient, &id, &payloadRx, &length))
        {
            switch (id)
            {
            case SYNCPROTOCOL_MESSAGE_ID_OSCILLOSCOPE_CONTROL_CMD:
            {
                Oscilloscope_MessageControlCmd* m = (Oscilloscope_MessageControlCmd*)payloadRx;

                if (m->flags.enabled)
                {
                    Ifx_Osci_start(bb->_osci);

                    if (Ifx_Osci_isRunning(bb->_osci))
                    {
                        bb->_osciChannelDataOffset = 0;
                        bb->_OsciChannelId         = 0;
                    }
                }
                else
                {
                    Ifx_Osci_stop(bb->_osci);
                }

                if (m->flags.triggerSingle)
                {
                    bb->_osciSingle = TRUE;
                }
                else
                {
                    bb->_osciSingle = FALSE;
                }

                /* Osci is always in single mode to enable coherent data transfer */
                Ifx_Osci_setTriggerSingle(bb->_osci, TRUE);

                switch (m->flags.triggerMode)
                {
                case 0:
                    Ifx_Osci_setTriggerMode(bb->_osci, Ifx_Osci_TriggerMode_normal);
                    break;
                case 1:
                    Ifx_Osci_setTriggerMode(bb->_osci, Ifx_Osci_TriggerMode_automatic);
                    break;
                case 2:
                    Ifx_Osci_setTriggerMode(bb->_osci, Ifx_Osci_TriggerMode_inverted);
                    break;
                }

                switch (m->flags.triggerEdge)
                {
                case 0:
                    Ifx_Osci_setTriggerEdge(bb->_osci, Ifx_Osci_TriggerEdge_falling);
                    break;
                case 1:
                    Ifx_Osci_setTriggerEdge(bb->_osci, Ifx_Osci_TriggerEdge_rising);
                    break;
                }

                Ifx_Osci_setTriggerLevel(bb->_osci, m->triggerLevel);

                Ifx_Osci_setSamplingInterval(bb->_osci, m->samplingInterval);
                Ifx_Osci_setTriggerSource(bb->_osci, m->triggerChannel);

                if (m->depth != 0)
                {
                    Ifx_Osci_setDepth(bb->_osci, m->depth);
                }
            }
                //_osciStateSend = FALSE;
                break;

            case SYNCPROTOCOL_MESSAGE_ID_OSCILLOSCOPE_GET_STATE_REQ:
            {
                bb->_osciStateSend       = FALSE;
                bb->_osciSignalInfoSend  = 0;
                bb->_osciChannelInfoSend = 0;
            }
            break;

            case SYNCPROTOCOL_MESSAGE_ID_OSCILLOSCOPE_ASSIGN_CHANNEL_CMD:
            {
                Oscilloscope_MessageAssignChannel* m = (Oscilloscope_MessageAssignChannel*)payloadRx;

                Ifx_Osci_associateSignalToChannel(bb->_osci, m->signalId, m->channelId);
            }
            break;
            case SYNCPROTOCOL_MESSAGE_ID_RAWBUFFER:
            {
                uint8* payloadTx = bb->_bbClientMessagePayloadTx;
                length = length > sizeof(bb->_bbClientMessagePayloadTx) ? sizeof(bb->_bbClientMessagePayloadTx) : length;

                if (SyncProtocol_setSendMessageBuffer(
                        &bb->_bbClient,
                        SYNCPROTOCOL_MESSAGE_ID_RAWBUFFER,
                        bb->_bbClientMessagePayloadTx,
                        length))
                {
                    uint32 i;
                    uint8* src = &payloadRx[0];
                    uint8* dst = &payloadTx[0];

                    for (i = 0; i < length; i++)
                    {
                        *dst++ = *src++;
                    }

                    SyncProtocol_sendMessage(&bb->_bbClient);
                }
            }
            break;
            }

            SyncProtocol_releaseReadMessageBuffer(&bb->_bbClient);
        }
    }

    Ifx_Osci_sendOscilloscopeSendChannelsData(bb);
}
