/*
 * \file syncprotocol.h
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *                            IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#ifndef SYNCPROTOCOL_H
#define SYNCPROTOCOL_H

#define SYNCPROTOCOL_VARIANT_QT    (1)
#define SYNCPROTOCOL_VARIANT_AURIX (2)
#define SYNCPROTOCOL_VARIANT       SYNCPROTOCOL_VARIANT_AURIX

/** Synchron, symetric binary protocol with handchecking
 *
 *
 * Features
 * - Data stream synchronisation by header and header checksum
 * - Symetrical protocol (No master / slave)
 * - Messages are send from a sender to a receiver linked by local and remote ports (Communication channels)
 * - Messages are split in multiple frames depending on the message size
 * - Frames have an header and payload checksum
 * - Frame header and payload acknowledge
 * - One message is buffered for send per port
 * - Resend frame header on error
 * - Resend frame payload on error
 * - Send and receive timeout
 *
 *
 * Frame use case :
 * 1) A sends, B acknowledge
 * A: Header - ... - PAYLOAD - ...
 * B: ...... - ACK - ....... - ACK
 *
 * 2) A and B sends at the same time
 * A: Header - ACK + PAYLOAD - ACK
 * B: Header - ACK + PAYLOAD - ACK
 *
 * 3) A and B sends at the same time
 * A: Header - ... - ACK + PAYLOAD - ACK
 * B: Header - ACK - ... - PAYLOAD - ACK
 *
 * 4) A sends, B acknowledge, error in header
 * A: Header - .... - HEADER - ... - PAYLOAD - ...
 * B: ...... - ACKN - ...... - ACK - ....... - ACK
 *
 * 5) A sends, B acknowledge, error in payload
 * A: Header - ... - PAYLOAD - .... - PAYLOAD - ...
 * B: ...... - ACK - ....... - ACKN - ....... - ACK
 *
 * 6) A sends, B does not acknowledge the header
 * A: Header - .................... (TIMEOUT)
 * B: ...... - ....................
 *
 * 7) A sends, B does not acknowledge the payload
 * A: Header - ... - PAYLOAD - .................... (TIMEOUT)
 * B: ...... - ACK - ....... - ............................ (TIMEOUT)
 *
 */
/*************************************/
#if SYNCPROTOCOL_VARIANT == SYNCPROTOCOL_VARIANT_QT
/* QT */
#include "fifo.h"

#define FALSE (false)
#define TRUE  (true)

typedef qint8  sint8;
typedef qint16 sint16;
typedef qint32 sint32;
typedef qint64 sint64;

typedef quint8  uint8;
typedef quint16 uint16;
typedef quint32 uint32;
typedef quint64 uint64;
typedef float   float32;
typedef bool    boolean;

typedef sint64 SyncProtocol_Time;
typedef Fifo   SyncProtocol_Fifo;

#elif SYNCPROTOCOL_VARIANT == SYNCPROTOCOL_VARIANT_AURIX

#include "Cpu/Std/Platform_Types.h"
#include "_Lib/DataHandling/Ifx_Fifo.h"
#include "Bsp.h"

typedef Ifx_TickTime SyncProtocol_Time;
typedef Ifx_Fifo     SyncProtocol_Fifo;

#endif

#ifdef __cplusplus
extern "C" {
#endif

/*-------------------------------------------------------------------------*/
/* SyncProtocol: Frame                                                     */
/*-------------------------------------------------------------------------*/
#define SYNCPROTOCOL_VERSION            0x01
#define SYNCPROTOCOL_PASSWORD           0x12345679
#define SYNCPROTOCOL_HEADER_START_BYTE  0xDE
#define SYNCPROTOCOL_PAYLOAD_START_BYTE 0xDF

/** Maximum frame index value. must be (x^2)-1, where x is an integer */
#define SYNCPROTOCOL_FRAME_MAX_INDEX     0x15
#define SYNCPROTOCOL_FRAME_INDEX_INVALID 0x0

typedef uint8 SyncProtocol_Port;
/** Max number of client. Range=[0,31] */
#define SYNCPROTOCOL_PORT_MAX  10
#define SYNCPROTOCOL_PORT_CORE 0x0
#define SYNCPROTOCOL_PORT_NONE 0xFF

typedef enum
{
    /** Value for SyncProtocol_FrameFlags.B.ack: No acknowledge information in header */
    SyncProtocol_Ack_none = 0x0,
    /** Value for SyncProtocol_FrameFlags.B.ack: The header is invalid */
    SyncProtocol_Ack_headerError = 0x1,
    /** Value for SyncProtocol_FrameFlags.B.ack: The port is not connected */
    SyncProtocol_Ack_portClosed = 0x2,
    /** Value for SyncProtocol_FrameFlags.B.ack: The driver is busy receiving a frame on the port */
    SyncProtocol_Ack_busy = 0x3,
    /** Value for SyncProtocol_FrameFlags.B.ack: The header is valid, frame acknowleged  */
    SyncProtocol_Ack_headerOk = 0x4,
    /** Value for SyncProtocol_FrameFlags.B.ack: The payload checksum is incorrect */
    SyncProtocol_Ack_payloadError = 0x5,
    /** Value for SyncProtocol_FrameFlags.B.ack: The paylaod checksum is correct */
    SyncProtocol_Ack_payloadOk = 0x6,
}SyncProtocol_Ack;

typedef enum
{
    SyncProtocol_FrameType_ack        = 0x0,
    SyncProtocol_FrameType_data       = 0x1,
    SyncProtocol_FrameType_dataStart  = 0x2,
    SyncProtocol_FrameType_dataMiddle = 0x3,
    SyncProtocol_FrameType_dataEnd    = 0x4,
}SyncProtocol_FrameType;

typedef union
{
    uint16 U;
    struct
    {
        uint8 b0;
        uint8 b1;
    }X;
    struct
    {
        uint16 frameType : 3;
#define SyncProtocol_FrameType_ack        0x0
#define SyncProtocol_FrameType_data       0x1
#define SyncProtocol_FrameType_dataStart  0x2
#define SyncProtocol_FrameType_dataMiddle 0x3
#define SyncProtocol_FrameType_dataEnd    0x4
        uint16 ack : 3;
        /**
         * @brief Index of the acknowlegde frame
         */
        uint16 indexAck : 4;
        /** the packet Index references the packet in a packet stream, the 1st
         * packet of the same data get the index 0, the 2nd index 1, ....
         * on overflow, the index starts at 0 again */
        uint16 index : 4;
        uint16 reserved : 2;
    }B;
}SyncProtocol_FrameFlags;

typedef unsigned char SyncProtocol_ChecksumHeader;
typedef unsigned char SyncProtocol_ChecksumPayload;

#define SYNCPROTOCOL_FRAME_PAYLOAD_MAX_LENGTH 254

/** \brief Gneral frame type
 */
typedef struct SyncProtocol_FrameHeader_
{
    /** Header start byte */
    uint8 startByte;
    /** Port that send the header */
    SyncProtocol_Port sender;
    /** Port to which the header is send */
    SyncProtocol_Port receiver;
    /** Payload length in byte */
    uint8 length;
    /** gives information about the content of the packet data */
    SyncProtocol_FrameFlags flags;
    /** Frame payload checksum */
    SyncProtocol_ChecksumPayload checksumPayload;
    /** Frame header checksum */
    SyncProtocol_ChecksumHeader checksumHeader;
}SyncProtocol_FrameHeader;

#define SYNCPROTOCOL_FRAME_HEADER_SIZE (sizeof(SyncProtocol_FrameHeader))

/*-------------------------------------------------------------------------*/
/* SyncProtocol: Message                                                   */
/*-------------------------------------------------------------------------*/
#define SYNCPROTOCOL_MESSAGE_PAYLOAD_MAX_LENGTH 640

typedef uint16 SyncProtocol_MessageId;

/**
 * Message ID definition
 * 0x00??  used by SyncProtocol, with ?=any value from 0x0 to 0xF
 * 0x1???  used by OneEye
 * 0x2???  reserved
 * 0x3???  reserved
 * 0xY???  free for use by any other application with ((Y>=4))
 *
 * \note ?=any value from 0x0 to 0xF
 */
#define SYNCPROTOCOL_MESSAGE_ID_RESERVED_BY_CORE 0x0FFF

/** Message header definition
 * sizeof(SyncProtocol_MessageHeader):8
 *
 * Message format example :
 * struct{
 *     SyncProtocol_MessageHeader header;
 *     uint8 payload[20];
 * }MessageExample;
 */
typedef struct
{
    SyncProtocol_MessageId id; /**< \brief ID of message */
    uint16 dummy;              /**< \brief Reserved, should be 0 & keep alignement on 32 bit */
    uint32 length;             /**< \brief Message length, including header  */
}SyncProtocol_MessageHeader;

#define SYNCPROTOCOL_MESSAGE_HEADER_SIZE (sizeof(SyncProtocol_MessageHeader))

/** Message: Request a specific message
 */
typedef struct
{
    SyncProtocol_MessageId id;                /**< \brief ID of the requested message */
}SyncProtocol_MessageRequest;

/** Message: Protocol information
 */
typedef struct
{
    uint32 password;                    /**< \brief Password identifying the protocol */
    uint8 version;                      /**< \brief Protocol version */
}SyncProtocol_MessageProtocolInfo;

/*-------------------------------------------------------------------------*/
/* SyncProtocol: Driver                                                    */
/*-------------------------------------------------------------------------*/
typedef struct _SyncProtocol SyncProtocol;

typedef struct
{
    /** Pointer to the protocol */
    SyncProtocol* protocol;
    /** Client local port */
    SyncProtocol_Port localPort;
    /** Client remote port */
    SyncProtocol_Port remotePort;

    struct
    {
        /** Indicate if the send message data is valid */
        boolean messageValid;
        /** Indicate if the last message could not be send  */
        boolean messageSendError;
        /** Message header to be send. Only valid is messageValid is set */
        SyncProtocol_MessageHeader messageHeader;
        /** Message payload to be send. Only valid is messageValid is set */
        uint8* messagePayload;
        /** Index of the next message data byte (header + payload) to be send. Only valid is messageValid is set  */
        uint32 messageByteIndex;
    }send;
    struct
    {
        /** Indicate if the received message data is valid */
        boolean messageValid;
        /** Buffer for the message header currently beeing received. Only valid is messageValid is set */
        SyncProtocol_MessageHeader messageHeader;
        /** Buffer for the message payload currently beeing received. Only valid is messageValid is set */
        uint8* messagePayload;
        /** Size of the messagePayload buffer */
        uint32 messagePayloadBufferSize;
        /** Index of the next message data byte to be received. Only valid is messageValid is set  */
        uint32 messageByteIndex;
    }receive;
}SyncProtocol_Client;

typedef enum
{
    SyncProtocol_SendState_readyForSend,
    SyncProtocol_SendState_prepareFrame,
    SyncProtocol_SendState_sendingHeader,
    SyncProtocol_SendState_waitingForHeaderAck,
    SyncProtocol_SendState_sendingPayloadStartByte,
    SyncProtocol_SendState_sendingPayload,
    SyncProtocol_SendState_waitingForPayloadAck,
}SyncProtocol_SendState;

typedef enum
{
    SyncProtocol_ReceiveState_waitingForHeader,
    SyncProtocol_ReceiveState_waitingForPayload,
    SyncProtocol_ReceiveState_readingPayload
}SyncProtocol_ReceiveState;

/** Max lenght of the message that the core can receive */
#define SYNCPROTOCOL_CORE_MESSAGE_PAYLOAD_MAX_LENGTH (32)

struct _SyncProtocol
{
    SyncProtocol_Fifo* streamIn;
    SyncProtocol_Fifo* streamOut;
    boolean streamInOwner;
    boolean streamOutOwner;

    /**
     * @brief Protocol synchronized for read, the last received header was valid
     */
    boolean synchronized;

    /** Next frame index to be send. valid frame index are from 1 to SYNCPROTOCOL_FRAME_MAX_INDEX */
    uint8 frameIndex;

    struct
    {
        uint32 invalidAckFrameIndex;
        uint32 invalidAckStatus;
        uint32 invalidFrameIndex;
        /** The header received has incorrect checksum */
        uint32 invalidHeader;
        uint32 pendingAckOverflow;
        uint32 portClosed;
        uint32 portBusy;
        uint32 invalidStartByte;
        uint32 payloadError;
        uint32 receiveTimeout;
        uint32 sendTimeout;
    } status;

    struct
    {
        /** Current send state */
        SyncProtocol_SendState state;

        /** Buffer for the header currently beeing send. Only valid in states SyncProtocol_SendState_sendingHeader, SyncProtocol_SendState_waitingForHeaderAck, SyncProtocol_SendState_sendingPayloadStartByte, SyncProtocol_SendState_sendingPayload, SyncProtocol_SendState_waitingForPayloadAck */
        SyncProtocol_FrameHeader header;
        /** Index of the next header data byte to be send. Only valid in states SyncProtocol_SendState_sendingHeader, SyncProtocol_SendState_waitingForHeaderAck, SyncProtocol_SendState_sendingPayloadStartByte, SyncProtocol_SendState_sendingPayload, SyncProtocol_SendState_waitingForPayloadAck  */
        uint8 frameHeaderByteIndex;
        /** Indicates if the header ACK have been received, or none is required. Only valid in states SyncProtocol_SendState_sendingHeader, SyncProtocol_SendState_waitingForHeaderAck, SyncProtocol_SendState_sendingPayloadStartByte, SyncProtocol_SendState_sendingPayload, SyncProtocol_SendState_waitingForPayloadAck */
        uint8 headerAckReceived;
        /** Index of the next payload data byte to be send. Only valid in states SyncProtocol_SendState_sendingHeader, SyncProtocol_SendState_waitingForHeaderAck, SyncProtocol_SendState_sendingPayloadStartByte, SyncProtocol_SendState_sendingPayload, SyncProtocol_SendState_waitingForPayloadAck  */
        uint8 framePayloadByteIndex;
        /** Indicates if the payload ACK have been received, or none is required. Only valid in states SyncProtocol_SendState_sendingHeader, SyncProtocol_SendState_waitingForHeaderAck, SyncProtocol_SendState_sendingPayloadStartByte, SyncProtocol_SendState_sendingPayload, SyncProtocol_SendState_waitingForPayloadAck */
        uint8 payloadAckReceived;
        /** Client who's message is currently beeing send */
        SyncProtocol_Client* currentClient;
        /** Pending ACK status to be send. See  SYNCPROTOCOL_FRAME_PACKET_TYPE_ACK_* */
        uint8 pendingAckStatus;
        /** Pending ACK frame index to be send */
        uint8 pendingAckFrameIndex;
        /** Indicate if the send ack header data is valid */
        boolean ackHeaderValid;
        /** Buffer for the ACK header. Only valid if ackHeaderValid is set */
        SyncProtocol_FrameHeader ackHeader;
        /** Index of the next ack header data byte to be send. Only valid if ackHeaderValid is set   */
        uint8 ackHeaderByteIndex;
        /** Send deadline after which the communication is reset if send is still pending */
        SyncProtocol_Time deadline;
    } send;

    struct
    {
        /** Current receive state */
        SyncProtocol_ReceiveState state;
        /** Buffer for the header currently beeing received */
        SyncProtocol_FrameHeader header;

        /** Buffer for the header currently received. Only valid in state SyncProtocol_ReceiveState_waitingForPayload and SyncProtocol_ReceiveState_readingPayload */
        SyncProtocol_FrameHeader payloadHeader;
        /** Index of the next header data byte to be received. Only valid in state SyncProtocol_ReceiveState_waitingForPayload and SyncProtocol_ReceiveState_readingPayload */
        uint8 frameHeaderByteIndex;
        /** Index of the next payload data byte to be received. Only valid in state SyncProtocol_ReceiveState_waitingForPayload and SyncProtocol_ReceiveState_readingPayload */
        uint8 framePayloadByteIndex;
        /** Last received valid frame index */
        uint8 lastValidFrameIndex;
        /** Receive deadline after which the communication is reset if receive is still pending */
        SyncProtocol_Time deadline;

        /** Buffer for the message payload currently beeing received. */
        uint8 messagePayload[SYNCPROTOCOL_CORE_MESSAGE_PAYLOAD_MAX_LENGTH];
    } receive;

    /** Frame timeout used for frame send and receive  */
    SyncProtocol_Time timeout;

    /** List of client pointers */
    SyncProtocol_Client* clients[SYNCPROTOCOL_PORT_MAX + 1];
    /** Core client data */
    SyncProtocol_Client core;
    /** Use to enable / disable core action */
    boolean coreLock;

    /** Set to TRUE when an ACK header is received between the frame header and the frame payload */
    boolean waitingForPayload;
};

/**
 * @brief Initialize the protocol
 * @param protocol Protocol to be initialized
 * @param timeout Timeout per byte in ms
 * @param streamIn If NULL, the stream in FIFO will be created by this API, else this streamIn FIFO is used
 * @param streamOut If NULL, the stream out FIFO will be created by this API, else this streamOut FIFO is used
 */
void SyncProtocol_init(SyncProtocol* protocol, sint32 timeout, SyncProtocol_Fifo* streamIn, SyncProtocol_Fifo* streamOut);


/**
 * @brief Return the RX and TX fifo size.
 * If the FIFOs are not created by the SyncProtocol, the size returned by this API must be used to initialize RX and TX FIFO
 */
uint32 SyncProtocol_getFifoSize(void);

/**
 * @brief De-initialize the protocol
 * @param protocol Protocol to be de-initialized
 */
void SyncProtocol_deinit(SyncProtocol* protocol);

/**
 * @brief Initialize and add a new client
 * @param protocol Protocol to which the client should be added
 * @param client Client to be added
 * @param port Client local port. Port \ref SYNCPROTOCOL_PORT_CORE is reserved by the \ref SyncProtocol
 * @param port Client remote port. Port \ref SYNCPROTOCOL_PORT_CORE is reserved by the \ref SyncProtocol
 * @param receiveMessagePayloadBuffer Buffer for the receive message
 * @param receiveMessagePayloadSize Size of the receive buffer
 * @return Return TRUE on success else FALSE. FALSE is returned if the client already exists and client pointer differs
 *
 */
boolean SyncProtocol_addClient(SyncProtocol* protocol, SyncProtocol_Client* client, SyncProtocol_Port localPort, SyncProtocol_Port remotePort, uint8* receiveMessagePayloadBuffer, uint32 receiveMessagePayloadSize);

/**
 * @brief Remove a client from the protocol handling
 * @param client Client to be removed
 */
void SyncProtocol_removeClient(SyncProtocol_Client* client);

/**
 * @brief Set the message send buffer and the message the id and length
 * @param client Protocol client
 * @param id Message ID
 * @param payloadLength Message payload length
 * @param messagePayload Pointer to the message payload.
 *                       The buffer should at least contains 'payloadLength' bytes.
 *                       The buffer must be available until the message is completely send.
 * @return Return TRUE on success else FALSE
 */
boolean SyncProtocol_setSendMessageBuffer(SyncProtocol_Client* client, SyncProtocol_MessageId id, uint8* messagePayload, uint32 payloadLength);

/**
 * @brief Send a message to the remote port
 * @param client Client that sends the message
 * @return Return TRUE on success, else FALSe. FALSE is returned if sending message is already ongoing
 */
boolean        SyncProtocol_sendMessage(SyncProtocol_Client* client);
/**
 * @brief Return TRUE if the protocol already sending data for the client
 * @param client Client to ge the status from
 * @return Return TRUE if the protocol already sending data for the client
 */
inline boolean SyncProtocol_isSendBusy(SyncProtocol_Client* client)
{ return client->send.messageValid; }

/**
 * @brief Set the message payload buffer
 * @param client
 * @param messagePayload Pointer to the buffer where the incomming message are stored
 * @param size size of the buffer in byte
 * @return return TRUE on success else FALSE
 */
boolean SyncProtocol_setReadMessageBuffer(SyncProtocol_Client* client, uint8* messagePayload, uint32 size);
/**
 * @brief Return a pointer on the last read message with the message header data
 * @param client Protocol client
 * @param payloadLength Size of the payload in byte
 * @param id Received message ID
 * @param messagePayload Pointer to the payload
 * @return Return a pointer on the message payload last read message or NULL if none
 */
boolean SyncProtocol_getReadMessageBuffer(SyncProtocol_Client* client, SyncProtocol_MessageId* id, uint8** messagePayload, uint32* payloadLength);

/**
 * @brief Release the read message buffer
 * @param client Client to ge the status from
 * @return Return TRUE if the protocol already sending data for the client
 */
void SyncProtocol_releaseReadMessageBuffer(SyncProtocol_Client* client);

/**
 * @brief Execute the protocol
 * @param protocol Protocol
 */
void SyncProtocol_execute(SyncProtocol* protocol);

/**
 * @brief Execute the protocol
 * @param protocol Protocol
 * @param timeout Send / receive timeout in ms
 */
inline void SyncProtocol_setTimeout(SyncProtocol* protocol, sint64 timeout)
{
#if SYNCPROTOCOL_VARIANT == SYNCPROTOCOL_VARIANT_QT
    protocol->timeout = timeout;
#elif SYNCPROTOCOL_VARIANT == SYNCPROTOCOL_VARIANT_AURIX
    protocol->timeout = timeout * TimeConst_1ms;
#endif
}


/**
 * @return Return the send / receive timeout in ms
 */
inline sint64 SyncProtocol_getTimeout(SyncProtocol* protocol)
{
#if SYNCPROTOCOL_VARIANT == SYNCPROTOCOL_VARIANT_QT
    return protocol->timeout;
#elif SYNCPROTOCOL_VARIANT == SYNCPROTOCOL_VARIANT_AURIX
    return protocol->timeout / TimeConst_1ms;
#endif
}


/**
 * @return Returns a pointer on the stream in FIFO
 */
inline SyncProtocol_Fifo* SyncProtocol_getStreamInFifo(SyncProtocol* protocol)
{ return protocol->streamIn; }

/**
 * @return Returns a pointer on the stream out FIFO
 */
inline SyncProtocol_Fifo* SyncProtocol_getStreamOutFifo(SyncProtocol* protocol)
{ return protocol->streamOut; }

/*-------------------------------------------------------------------------*/
/* SyncProtocol: Custom message definition                                        */
/*-------------------------------------------------------------------------*/
/* Note: When defining a message, the following must be cared about
 * - __attribute__((__packed__)) should be use to ensure compatibility between compilers. Packed is valid for GNU compilers
 * - Member of struct must be aligned so that no alignment error are triggered by the CPU
 *   - uint8, sint8, char, data aligned on 8 bit
 *   - uint16, sint16, data aligned on 16 bit
 *   - uint32, sint32, float32, data aligned on 16 bit
 */

#define SYNCPROTOCOL_MESSAGE_ID_RAWDATA   (0x1000)    /**< \see SyncProtocol_MessageRawData */
#define SYNCPROTOCOL_MESSAGE_ID_RAWBUFFER (0x1001)    /**< \see SyncProtocol_MessageRawBuffer */

typedef enum
{
    SyncProtocol_MessageRawData_Type_uint8    = 0x0,
    SyncProtocol_MessageRawData_Type_sint8    = 0x1,
    SyncProtocol_MessageRawData_Type_uint16   = 0x2,
    SyncProtocol_MessageRawData_Type_sint16   = 0x3,
    SyncProtocol_MessageRawData_Type_uint32   = 0x4,
    SyncProtocol_MessageRawData_Type_sint32   = 0x5,
    SyncProtocol_MessageRawData_Type_uint64   = 0x6,
    SyncProtocol_MessageRawData_Type_sint64   = 0x7,
    SyncProtocol_MessageRawData_Type_float32  = 0x8,
    SyncProtocol_MessageRawData_Type_char     = 0x9,
    SyncProtocol_MessageRawData_Type_bit      = 0xA,
    SyncProtocol_MessageRawData_Type_bitfield = 0xB,
    SyncProtocol_MessageRawData_Type_register = 0xC,
}SyncProtocol_MessageRawData_Type;

#if defined(__HIGHTEC__)
typedef struct __attribute__ ((__packed__))
#elif defined(__TASKING__)
typedef struct
#else
typedef struct
#endif
{
    union
    {
        uint8 asUint8;
        sint8 asSint8;
        uint16 asUint16;
        sint16 asSint16;
        uint32 asUint32;
        sint32 asSint32;
        uint64 asUint64;
        sint64 asSint64;
        float32 asFloat32;
    }data;
    uint8 type;
}SyncProtocol_MessageRawData;

#if defined(__HIGHTEC__)
typedef struct __attribute__ ((__packed__))
#elif defined(__TASKING__)
typedef struct
#else
typedef struct
#endif
{
    char payload[SYNCPROTOCOL_MESSAGE_PAYLOAD_MAX_LENGTH];
}SyncProtocol_MessageRawBuffer;

#ifdef __cplusplus
}
#endif

#endif
