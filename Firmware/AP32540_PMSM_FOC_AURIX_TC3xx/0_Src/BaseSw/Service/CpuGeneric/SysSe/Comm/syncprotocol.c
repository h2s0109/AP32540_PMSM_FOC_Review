/*
 * \file syncprotocol.c
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *                            IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#include "syncprotocol.h"

#if SYNCPROTOCOL_VARIANT == SYNCPROTOCOL_VARIANT_QT
/* QT */
#include <QDebug>
#include <QDateTime>

/** Print debug information */
//#define SYNCPROTOCOL_DEBUG(INFO) qInfo() << INFO
#define SYNCPROTOCOL_DEBUG(INFO)
#define ASSERT(X) Q_ASSERT_X(X, "", "")
#define SYNCPROTOCOL_CURRENT_TIME QDateTime::currentMSecsSinceEpoch()

#elif SYNCPROTOCOL_VARIANT == SYNCPROTOCOL_VARIANT_AURIX

#include "Ifx_Assert.h"

#define SYNCPROTOCOL_DEBUG(INFO)
#define ASSERT(X) IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, X)

#define SYNCPROTOCOL_CURRENT_TIME now()

#endif

/**
 * @brief Calculate the checksum of the header
 * @param header Header
 * @return checksum
 */
static uint8 SyncProtocol_calculateFrameHeaderChecksum(SyncProtocol_FrameHeader* header);
/**
 * @brief Calculate the checksum of the payload
 * @param header Frame header
 * @param messageHeader Message header
 * @param messagePayload Message payload
 * @return checksum
 */
static uint8 SyncProtocol_calculateFramePayloadChecksum(SyncProtocol_FrameHeader* header, SyncProtocol_MessageHeader* messageHeader, uint8* messagePayload);
static uint8 SyncProtocol_getNextIndex(uint8 currentIndex);
static uint8 SyncProtocol_getNewIndex(SyncProtocol* protocol);

/**
 * @brief Fill in the ACK information and return TRUE if ACK need to be send
 */
static boolean SyncProtocol_setAck(SyncProtocol* protocol, SyncProtocol_FrameHeader* header);

/**
 * @brief Send the frame
 *
 * The whole frame might be send over multiple call
 *
 */
static boolean SyncProtocol_sendPayload(SyncProtocol* protocol);
static boolean SyncProtocol_checkPendingAck(SyncProtocol* protocol);
static void    SyncProtocol_processOutgoing(SyncProtocol* protocol);
static void    SyncProtocol_raiseAck(SyncProtocol* protocol, uint8 frameIndex, uint8 ackStatus);
static void    SyncProtocol_processAck(SyncProtocol* protocol, SyncProtocol_FrameHeader* header);
static void    SyncProtocol_readHeader(SyncProtocol* protocol);
static void    SyncProtocol_processIncomming(SyncProtocol* protocol);

#if SYNCPROTOCOL_VARIANT == SYNCPROTOCOL_VARIANT_QT
static inline Fifo::BufferSize SyncProtocol_fifoWrite(SyncProtocol_Fifo* fifo, const void* data, Fifo::BufferSize count)
{
    return fifo->write(data, count, 0);
}


static inline Fifo::BufferSize SyncProtocol_fifoRead(SyncProtocol_Fifo* fifo, void* data, Fifo::BufferSize count)
{
    return fifo->read(data, count, 0);
}


#elif SYNCPROTOCOL_VARIANT == SYNCPROTOCOL_VARIANT_AURIX
static inline Ifx_SizeT SyncProtocol_fifoWrite(SyncProtocol_Fifo* fifo, const void* data, Ifx_SizeT count)
{
    return Ifx_Fifo_write(fifo, data, count, 0);
}


static inline Ifx_SizeT SyncProtocol_fifoRead(SyncProtocol_Fifo* fifo, void* data, Ifx_SizeT count)
{
    return Ifx_Fifo_read(fifo, data, count, 0);
}


#endif

/*-------------------------------------------------------------------------*/
/* SyncProtocol: Client server API                                         */
/*-------------------------------------------------------------------------*/
uint32 SyncProtocol_getFifoSize(void)
{
	return sizeof(SyncProtocol_FrameHeader) * 2 + SYNCPROTOCOL_FRAME_PAYLOAD_MAX_LENGTH + 2;
}

void SyncProtocol_init(SyncProtocol* protocol, sint32 timeout, SyncProtocol_Fifo* streamIn, SyncProtocol_Fifo* streamOut)
{
    SyncProtocol_Port port;
    SYNCPROTOCOL_DEBUG(QString("SyncProtocol_init [%1]").arg((uint64)protocol, 0, 16));
    ASSERT(SYNCPROTOCOL_FRAME_PAYLOAD_MAX_LENGTH > SYNCPROTOCOL_MESSAGE_HEADER_SIZE); /* When a message should be send, a the frame payload should at least fit the message header  */
    ASSERT(SYNCPROTOCOL_PORT_MAX < SYNCPROTOCOL_PORT_NONE);

#if SYNCPROTOCOL_VARIANT == SYNCPROTOCOL_VARIANT_QT
    protocol->timeout   = timeout; /* Should be longer than the frame  (SYNCPROTOCOL_FRAME_HEADER_SIZE*3 + SYNCPROTOCOL_FRAME_PAYLOAD_MAX_LENGTH + 1) + repeat in case of error */
#elif SYNCPROTOCOL_VARIANT == SYNCPROTOCOL_VARIANT_AURIX
    protocol->timeout   = timeout * TimeConst_1ms; /* Should be longer than the frame  (SYNCPROTOCOL_FRAME_HEADER_SIZE*3 + SYNCPROTOCOL_FRAME_PAYLOAD_MAX_LENGTH + 1) + repeat in case of error */
#endif
    protocol->streamInOwner = streamIn == NULL;
    protocol->streamOutOwner = streamOut == NULL;

    if (protocol->streamInOwner)
    {
#if SYNCPROTOCOL_VARIANT == SYNCPROTOCOL_VARIANT_QT
        protocol->streamIn  = new Fifo(SyncProtocol_getFifoSize(), 1);
#elif SYNCPROTOCOL_VARIANT == SYNCPROTOCOL_VARIANT_AURIX
        protocol->streamIn  = Ifx_Fifo_create(SyncProtocol_getFifoSize(), 1);
#endif
    }
    else
    {
    	protocol->streamIn = streamIn;
    }

    if (protocol->streamOutOwner)
    {
#if SYNCPROTOCOL_VARIANT == SYNCPROTOCOL_VARIANT_QT
        protocol->streamOut = new Fifo(SyncProtocol_getFifoSize(), 1);
#elif SYNCPROTOCOL_VARIANT == SYNCPROTOCOL_VARIANT_AURIX
        protocol->streamOut = Ifx_Fifo_create(SyncProtocol_getFifoSize(), 1);
#endif
    }
    else
    {
    	protocol->streamOut = streamOut;
    }

    /* Assume clean synchornized startup */
    protocol->synchronized                          = TRUE;
    protocol->frameIndex                            = SYNCPROTOCOL_FRAME_INDEX_INVALID;

    protocol->status.invalidAckFrameIndex           = 0;
    protocol->status.invalidAckStatus               = 0;
    protocol->status.invalidFrameIndex              = 0;
    protocol->status.invalidHeader                  = 0;
    protocol->status.pendingAckOverflow             = 0;
    protocol->status.portClosed                     = 0;
    protocol->status.portBusy                       = 0;
    protocol->status.invalidStartByte               = 0;
    protocol->status.payloadError                   = 0;
    protocol->status.receiveTimeout                 = 0;
    protocol->status.sendTimeout                    = 0;

    protocol->send.state                            = SyncProtocol_SendState_readyForSend;

    protocol->send.header.startByte                 = SYNCPROTOCOL_HEADER_START_BYTE;
    protocol->send.header.sender                    = SYNCPROTOCOL_PORT_NONE;
    protocol->send.header.receiver                  = SYNCPROTOCOL_PORT_NONE;
    protocol->send.header.flags.U                   = 0;
    protocol->send.header.checksumHeader            = 0;
    protocol->send.header.length                    = 0;
    protocol->send.header.checksumPayload           = 0;
    protocol->send.frameHeaderByteIndex             = 0;
    protocol->send.headerAckReceived                = SyncProtocol_Ack_none;
    protocol->send.framePayloadByteIndex            = 0;
    protocol->send.payloadAckReceived               = SyncProtocol_Ack_none;
    protocol->send.currentClient                    = NULL;
    protocol->send.pendingAckStatus                 = SyncProtocol_Ack_none;
    protocol->send.pendingAckFrameIndex             = SYNCPROTOCOL_FRAME_INDEX_INVALID;
    protocol->send.ackHeaderValid                   = FALSE;
    protocol->send.ackHeader.startByte              = SYNCPROTOCOL_HEADER_START_BYTE;
    protocol->send.ackHeader.sender                 = SYNCPROTOCOL_PORT_CORE;
    protocol->send.ackHeader.receiver               = SYNCPROTOCOL_PORT_CORE;
    protocol->send.ackHeader.flags.U                = 0;
    protocol->send.ackHeader.flags.B.frameType      = SyncProtocol_FrameType_ack;
    protocol->send.ackHeader.checksumHeader         = 0;
    protocol->send.ackHeader.length                 = 0;
    protocol->send.ackHeader.checksumPayload        = 0;
    protocol->send.ackHeaderByteIndex               = 0;

    protocol->receive.state                         = SyncProtocol_ReceiveState_waitingForHeader;
    protocol->receive.header.startByte              = (uint8) ~SYNCPROTOCOL_HEADER_START_BYTE;
    protocol->receive.header.sender                 = SYNCPROTOCOL_PORT_NONE;
    protocol->receive.header.receiver               = SYNCPROTOCOL_PORT_NONE;
    protocol->receive.header.flags.U                = 0;
    protocol->receive.header.checksumHeader         = 0;
    protocol->receive.header.length                 = 0;
    protocol->receive.header.checksumPayload        = 0;
    protocol->receive.payloadHeader.startByte       = SYNCPROTOCOL_HEADER_START_BYTE;
    protocol->receive.payloadHeader.sender          = SYNCPROTOCOL_PORT_NONE;
    protocol->receive.payloadHeader.receiver        = SYNCPROTOCOL_PORT_NONE;
    protocol->receive.payloadHeader.flags.U         = 0;
    protocol->receive.payloadHeader.checksumHeader  = 0;
    protocol->receive.payloadHeader.length          = 0;
    protocol->receive.payloadHeader.checksumPayload = 0;
    protocol->receive.frameHeaderByteIndex          = 0;
    protocol->receive.framePayloadByteIndex         = 0;
    protocol->receive.lastValidFrameIndex           = SYNCPROTOCOL_FRAME_INDEX_INVALID;

    for (port = 0; port <= SYNCPROTOCOL_PORT_MAX; port++)
    {
        protocol->clients[port] = NULL;
    }

    /* Add core as a lient */
    protocol->coreLock          = FALSE;
    SyncProtocol_addClient(protocol, &protocol->core, SYNCPROTOCOL_PORT_CORE, SYNCPROTOCOL_PORT_CORE, protocol->receive.messagePayload, SYNCPROTOCOL_CORE_MESSAGE_PAYLOAD_MAX_LENGTH);
    protocol->coreLock          = TRUE;
    protocol->waitingForPayload = FALSE;
}


void SyncProtocol_deinit(SyncProtocol* protocol)
{
    SyncProtocol_Port port;
    SYNCPROTOCOL_DEBUG(QString("SyncProtocol_deinit [%1]").arg((uint64)protocol, 0, 16));
    protocol->coreLock = FALSE;

    for (port = 0; port <= SYNCPROTOCOL_PORT_MAX; port++)
    {
        SyncProtocol_removeClient(protocol->clients[port]);
    }

    protocol->coreLock = TRUE;
    if (protocol->streamInOwner)
    {
#if SYNCPROTOCOL_VARIANT == SYNCPROTOCOL_VARIANT_QT
    delete protocol->streamIn;
#elif SYNCPROTOCOL_VARIANT == SYNCPROTOCOL_VARIANT_AURIX
    Ifx_Fifo_destroy(protocol->streamIn);
#endif

    }
    if (protocol->streamOutOwner)
    {
#if SYNCPROTOCOL_VARIANT == SYNCPROTOCOL_VARIANT_QT
    delete protocol->streamOut;
#elif SYNCPROTOCOL_VARIANT == SYNCPROTOCOL_VARIANT_AURIX
    Ifx_Fifo_destroy(protocol->streamOut);
#endif

    }

}


boolean SyncProtocol_addClient(SyncProtocol* protocol, SyncProtocol_Client* client, SyncProtocol_Port localPort, SyncProtocol_Port remotePort, uint8* receiveMessagePayloadBuffer, uint32 receiveMessagePayloadSize)
{
    if (localPort > SYNCPROTOCOL_PORT_MAX)
    {
        return FALSE; /* ClientId too big */
    }
    else if (localPort == SYNCPROTOCOL_PORT_NONE)
    {
        return FALSE; /* SYNCPROTOCOL_PORT_NONE is not a client */
    }
    else if (remotePort == SYNCPROTOCOL_PORT_NONE)
    {
        return FALSE; /* SYNCPROTOCOL_PORT_NONE is not a client */
    }
    else if ((localPort == SYNCPROTOCOL_PORT_CORE) && protocol->coreLock)
    {
        return FALSE; /* Core port is reserved */
    }
    else if ((remotePort == SYNCPROTOCOL_PORT_CORE) && protocol->coreLock)
    {
        return FALSE; /* Core port is reserved */
    }

    /* Check if the ClientId is in use */
    if (!protocol->clients[localPort])
    {
        SYNCPROTOCOL_DEBUG(QString("SyncProtocol_addClient [%1]: localPort=%2, remotePort=%3").arg((uint64)protocol, 0, 16).arg(localPort).arg(remotePort));
        /* Initialize the client */
        client->protocol                         = protocol;
        client->localPort                        = localPort;
        client->remotePort                       = remotePort;
        client->send.messageValid                = FALSE;
        client->send.messageSendError            = FALSE;
        client->send.messageHeader.length        = 0;
        client->send.messageHeader.id            = 0;
        client->send.messageHeader.dummy         = 0;
        client->send.messagePayload              = NULL;
        client->send.messageByteIndex            = 0;

        client->receive.messageValid             = FALSE;
        client->receive.messageHeader.length     = 0;
        client->receive.messageHeader.id         = 0;
        client->receive.messageHeader.dummy      = 0;
        client->receive.messagePayload           = receiveMessagePayloadBuffer;
        client->receive.messagePayloadBufferSize = receiveMessagePayloadSize;
        client->receive.messageByteIndex         = 0;
        protocol->clients[localPort]             = client;
        return TRUE;
    }
    else
    {
        SYNCPROTOCOL_DEBUG(QString("SyncProtocol_addClient [%1]: Already available, localPort=%2, remotePort=%3").arg((uint64)protocol, 0, 16).arg(localPort).arg(remotePort));
        return protocol->clients[localPort] == client;
    }
}


void SyncProtocol_removeClient(SyncProtocol_Client* client)
{   /* FIXME client can only be removed if not currently sending */
    if (client
        && (client->protocol != NULL)
        && (client->localPort <= SYNCPROTOCOL_PORT_MAX)
        && ((client->localPort > SYNCPROTOCOL_PORT_CORE) || !client->protocol->coreLock)
        )
    {
        SYNCPROTOCOL_DEBUG(QString("SyncProtocol_removeClient [%1]: localPort=%2").arg((uint64)client->protocol, 0, 16).arg(client->localPort));
        client->protocol->clients[client->localPort] = NULL;
        client->protocol                             = NULL;
    }
}


void SyncProtocol_execute(SyncProtocol* protocol)
{
    SyncProtocol_processIncomming(protocol);
    SyncProtocol_processOutgoing(protocol);
}


static uint8 SyncProtocol_calculateFrameHeaderChecksum(SyncProtocol_FrameHeader* header)
{
    return 1
           + (
        header->startByte
        + header->sender
        + header->receiver
        + header->flags.X.b0
        + header->flags.X.b1
        + header->length
        + header->checksumPayload
        );
}


static uint8 SyncProtocol_calculateFramePayloadChecksum(SyncProtocol_FrameHeader* header, SyncProtocol_MessageHeader* messageHeader, uint8* messagePayload)
{
    uint32 i;
    uint8  checksum = 0;

    if (messageHeader != NULL)
    {
        for (i = 0; i < SYNCPROTOCOL_MESSAGE_HEADER_SIZE; i++)
        {
            checksum += ((uint8*)messageHeader)[i];
        }

        for (i = 0; i < header->length - SYNCPROTOCOL_MESSAGE_HEADER_SIZE; i++)
        {
            checksum += messagePayload[i];
        }
    }
    else
    {
        for (i = 0; i < header->length; i++)
        {
            checksum += messagePayload[i];
        }
    }

    return 256 - checksum;
}


/*-------------------------------------------------------------------------*/
/* SyncProtocol: Client send API                                           */
/*-------------------------------------------------------------------------*/

boolean SyncProtocol_setSendMessageBuffer(SyncProtocol_Client* client, SyncProtocol_MessageId id, uint8* messagePayload, uint32 payloadLength)
{
    if (client->send.messageValid)
    {
        /* Last message not yet send or send process already on going */
        return FALSE;
    }

    if (id > SYNCPROTOCOL_MESSAGE_ID_RESERVED_BY_CORE)
    {
        SYNCPROTOCOL_DEBUG(QString("SyncProtocol_setSendMessageBuffer [%1]: id=0x%2, length=%3").arg((uint64)client->protocol, 0, 16).arg(id, 0, 16).arg(payloadLength));
        client->send.messageHeader.id     = id;
        client->send.messageHeader.dummy  = 0;
        client->send.messageHeader.length = SYNCPROTOCOL_MESSAGE_HEADER_SIZE + payloadLength;
        client->send.messagePayload       = messagePayload;
        return TRUE;
    }
    else
    {
        SYNCPROTOCOL_DEBUG(QString("SyncProtocol_setSendMessageBuffer [%1]: ERROR : id=0x%2, length=%3").arg((uint64)client->protocol, 0, 16).arg(id, 0, 16).arg(payloadLength));
        return FALSE;
    }
}


boolean SyncProtocol_sendMessage(SyncProtocol_Client* client)
{
    SyncProtocol* protocol = client->protocol;

    /* Do not send if client already busy or core is client or, message length is too long  */
    if ((client->send.messageValid)
        || (client == &protocol->core)
        || (client->send.messageHeader.id <= SYNCPROTOCOL_MESSAGE_ID_RESERVED_BY_CORE)
        )
    {
        SYNCPROTOCOL_DEBUG(QString("SyncProtocol_sendMessage [%1]: ERROR : localPort=0x%2, remotePort=%3, id=0x%4").arg((uint64)client->protocol, 0, 16).arg(client->localPort).arg(client->remotePort).arg(client->send.messageHeader.id, 0, 16));
        return FALSE;
    }

    /* Initialize the message sending process  */
    SYNCPROTOCOL_DEBUG(QString("SyncProtocol_sendMessage [%1]: localPort=0x%2, remotePort=%3, id=0x%4").arg((uint64)client->protocol, 0, 16).arg(client->localPort).arg(client->remotePort).arg(client->send.messageHeader.id, 0, 16));
    client->send.messageByteIndex = 0;
    client->send.messageSendError = FALSE;
    client->send.messageValid     = TRUE;

    return TRUE;
}


static uint8 SyncProtocol_getNextIndex(uint8 currentIndex)
{
    currentIndex = (currentIndex + 1) & SYNCPROTOCOL_FRAME_MAX_INDEX;

    if (currentIndex == 0)
    {
        currentIndex = 1;
    }

    return currentIndex;
}


static uint8 SyncProtocol_getNewIndex(SyncProtocol* protocol)
{
    return SyncProtocol_getNextIndex(protocol->frameIndex);
}


static boolean SyncProtocol_setAck(SyncProtocol* protocol, SyncProtocol_FrameHeader* header)
{
    boolean result;

    if (protocol->send.pendingAckStatus != SyncProtocol_Ack_none)
    {
        header->flags.B.ack             = protocol->send.pendingAckStatus;
        header->flags.B.indexAck        = protocol->send.pendingAckFrameIndex;
        protocol->send.pendingAckStatus = SyncProtocol_Ack_none;
        SYNCPROTOCOL_DEBUG(QString("SyncProtocol_setAck [%1]: ack=%2, frameIndex=%3").arg((uint64)protocol, 0, 16).arg(header->flags.B.ack).arg(header->flags.B.indexAck));
        result                          = TRUE;
    }
    else
    {
        header->flags.B.ack      = SyncProtocol_Ack_none;
        header->flags.B.indexAck = SYNCPROTOCOL_FRAME_INDEX_INVALID;
        result                   = FALSE;
    }

    return result;
}


void SyncProtocol_prepareFrame(SyncProtocol* protocol)
{
    SyncProtocol_Client*      client = protocol->send.currentClient;
    SyncProtocol_FrameHeader* header = &protocol->send.header;

    ASSERT(protocol->send.currentClient != NULL);
    ASSERT(client->send.messageValid == TRUE);

    uint32 chunk;
    SyncProtocol_setAck(protocol, header);
    header->sender   = client->localPort;
    header->receiver = client->remotePort;

    /* Fill header */
    chunk = client->send.messageHeader.length - client->send.messageByteIndex;

    if (chunk > SYNCPROTOCOL_FRAME_PAYLOAD_MAX_LENGTH)
    {
        if (client->send.messageByteIndex == 0)
        {
            header->flags.B.frameType = SyncProtocol_FrameType_dataStart;
        }
        else
        {
            header->flags.B.frameType = SyncProtocol_FrameType_dataMiddle;
        }

        header->length = SYNCPROTOCOL_FRAME_PAYLOAD_MAX_LENGTH;
    }
    else
    {
        if (client->send.messageHeader.length > SYNCPROTOCOL_FRAME_PAYLOAD_MAX_LENGTH)
        {
            header->flags.B.frameType = SyncProtocol_FrameType_dataEnd;
        }
        else
        {
            header->flags.B.frameType = SyncProtocol_FrameType_data;
        }

        header->length = chunk;
    }

    header->flags.B.index = SyncProtocol_getNewIndex(protocol);

    if (client->send.messageByteIndex == 0)
    {
        header->checksumPayload = SyncProtocol_calculateFramePayloadChecksum(
            header,
            &client->send.messageHeader,
            &client->send.messagePayload[0]);
    }
    else
    {
        header->checksumPayload = SyncProtocol_calculateFramePayloadChecksum(
            header,
            NULL,
            &client->send.messagePayload[client->send.messageByteIndex - SYNCPROTOCOL_MESSAGE_HEADER_SIZE]);
    }

    header->checksumHeader = SyncProtocol_calculateFrameHeaderChecksum(header);

    /* Prepare for send */
    protocol->send.frameHeaderByteIndex  = 0;
    protocol->send.headerAckReceived     = SyncProtocol_Ack_none;
    protocol->send.framePayloadByteIndex = 0;
    protocol->send.payloadAckReceived    = SyncProtocol_Ack_none;
    SYNCPROTOCOL_DEBUG(QString("SyncProtocol_prepareFrame [%1]: frameType=%2, frameIndex=%3, length=%4").arg((uint64)client->protocol, 0, 16).arg(header->flags.B.frameType).arg(header->flags.B.index).arg(header->length));
}


static boolean SyncProtocol_sendPayload(SyncProtocol* protocol)
{
    SyncProtocol_Client*      client = protocol->send.currentClient;
    SyncProtocol_FrameHeader* header = &protocol->send.header;

    ASSERT(protocol->send.currentClient != NULL);
    ASSERT(client->send.messageValid == TRUE);
    ASSERT(protocol->send.framePayloadByteIndex < header->length);
    ASSERT(header->length > 0);

    sint32 writeCount;

    /* Send message header */
    writeCount = SYNCPROTOCOL_MESSAGE_HEADER_SIZE - protocol->send.framePayloadByteIndex;

    if (writeCount > 0)
    {
        writeCount                            = writeCount - SyncProtocol_fifoWrite(protocol->streamOut, (void*)&((uint8*)&client->send.messageHeader)[client->send.messageByteIndex], writeCount);
        protocol->send.framePayloadByteIndex += writeCount;
        client->send.messageByteIndex        += writeCount;
    }

    if (client->send.messageByteIndex >= SYNCPROTOCOL_MESSAGE_HEADER_SIZE)
    {
        /* Send message payload */
        writeCount = header->length - protocol->send.framePayloadByteIndex;

        if (writeCount > 0)
        {
            writeCount                            = writeCount - SyncProtocol_fifoWrite(protocol->streamOut, (void*)&client->send.messagePayload[client->send.messageByteIndex - SYNCPROTOCOL_MESSAGE_HEADER_SIZE], writeCount);
            protocol->send.framePayloadByteIndex += writeCount;
            client->send.messageByteIndex        += writeCount;
        }
    }

    return header->length == protocol->send.framePayloadByteIndex;
}


static boolean SyncProtocol_checkPendingAck(SyncProtocol* protocol)
{
    boolean result;
    ASSERT(
        (protocol->send.state == SyncProtocol_SendState_readyForSend)
        || (protocol->send.state == SyncProtocol_SendState_waitingForHeaderAck)
        || (protocol->send.state == SyncProtocol_SendState_waitingForPayloadAck));

    if (protocol->send.pendingAckStatus != SyncProtocol_Ack_none)
    {
        SyncProtocol_FrameHeader* header = &protocol->send.ackHeader;

        SYNCPROTOCOL_DEBUG(QString("SyncProtocol_checkPendingAck [%1]: Sending Acknoledge").arg((uint64)protocol, 0, 16));
        SyncProtocol_setAck(protocol, header);

        header->flags.B.index   = SyncProtocol_getNewIndex(protocol);

        header->checksumPayload = SyncProtocol_calculateFramePayloadChecksum(header, NULL, NULL);
        header->checksumHeader  = SyncProtocol_calculateFrameHeaderChecksum(header);

        /* Prepare for send */
        protocol->send.ackHeaderByteIndex = 0;

        result                            = TRUE;
    }
    else
    {
        result = FALSE;
    }

    return result;
}


static void SyncProtocol_processOutgoing(SyncProtocol* protocol)
{
    SyncProtocol_FrameHeader* header = &protocol->send.header;

    if (protocol->send.ackHeaderValid)
    {
        sint32 writeCount;
        writeCount = SYNCPROTOCOL_FRAME_HEADER_SIZE - protocol->send.ackHeaderByteIndex;
        ASSERT(writeCount > 0);

        writeCount                         = writeCount - SyncProtocol_fifoWrite(protocol->streamOut, (void*)&((uint8*)&protocol->send.ackHeader)[protocol->send.ackHeaderByteIndex], writeCount);
        protocol->send.ackHeaderByteIndex += writeCount;

        if (protocol->send.ackHeaderByteIndex == SYNCPROTOCOL_FRAME_HEADER_SIZE)
        {
            SYNCPROTOCOL_DEBUG(QString("SyncProtocol_processOutgoing [%1]: Ack header send : frameType=%2, frameIndex=%3, length=%4").arg((uint64)protocol, 0, 16).arg(protocol->send.ackHeader.flags.B.frameType).arg(protocol->send.ackHeader.flags.B.index).arg(protocol->send.ackHeader.length));
            protocol->send.ackHeaderValid = FALSE;
        }
    }
    /* If an header is currently beeing send, continue sending */
    else if (protocol->send.state == SyncProtocol_SendState_readyForSend)
    {
        ASSERT(protocol->send.currentClient == NULL);

        /* Check if a client is waiting for send, enable it */
        SyncProtocol_Port port;

        for (port = 0; port <= SYNCPROTOCOL_PORT_MAX; port++)
        {
            SyncProtocol_Client* client = protocol->clients[port];

            if (client != NULL)
            {
                if (client->send.messageValid)
                {
                    protocol->send.currentClient = client;
                    protocol->send.state         = SyncProtocol_SendState_prepareFrame;
                    SYNCPROTOCOL_DEBUG(QString("SyncProtocol_processOutgoing [%1]: Client mark for send : localPort=%2").arg((uint64)protocol, 0, 16).arg(client->localPort));
                    break;
                }
            }
        }

        if ((protocol->send.currentClient == NULL) && SyncProtocol_checkPendingAck(protocol))
        {
            protocol->send.ackHeaderValid     = TRUE;
            protocol->send.ackHeaderByteIndex = 0;
        }
    }
    else if (protocol->send.state == SyncProtocol_SendState_prepareFrame)
    {
        SyncProtocol_prepareFrame(protocol);
        protocol->send.state    = SyncProtocol_SendState_sendingHeader;
        protocol->send.deadline = SYNCPROTOCOL_CURRENT_TIME + protocol->timeout;
    }
    else if (protocol->send.deadline <= SYNCPROTOCOL_CURRENT_TIME)
    {
        protocol->status.sendTimeout++;
        protocol->send.currentClient->send.messageValid     = FALSE;
        protocol->send.currentClient->send.messageSendError = TRUE;
        protocol->send.currentClient                        = NULL;
        protocol->send.state                                = SyncProtocol_SendState_readyForSend;
        SYNCPROTOCOL_DEBUG(QString("SyncProtocol_processOutgoing [%1]: Send timeout").arg((uint64)protocol, 0, 16));
    }
    else if (protocol->send.state == SyncProtocol_SendState_sendingHeader)
    {
        sint32 writeCount;
        writeCount = SYNCPROTOCOL_FRAME_HEADER_SIZE - protocol->send.frameHeaderByteIndex;
        ASSERT(writeCount > 0);

        writeCount                           = writeCount - SyncProtocol_fifoWrite(protocol->streamOut, (void*)&((uint8*)&protocol->send.header)[protocol->send.frameHeaderByteIndex], writeCount);
        protocol->send.frameHeaderByteIndex += writeCount;

        if (protocol->send.frameHeaderByteIndex == SYNCPROTOCOL_FRAME_HEADER_SIZE)
        {
            SYNCPROTOCOL_DEBUG(QString("SyncProtocol_processOutgoing [%1]: Header send : frameType=%2, frameIndex=%3, length=%4").arg((uint64)protocol, 0, 16).arg(protocol->send.header.flags.B.frameType).arg(protocol->send.header.flags.B.index).arg(protocol->send.header.length));
            protocol->send.headerAckReceived = SyncProtocol_Ack_none; /* FIXME might not be required */
            protocol->send.state             = SyncProtocol_SendState_waitingForHeaderAck;
        }
    }
    else if (protocol->send.state == SyncProtocol_SendState_waitingForHeaderAck)
    {
        if (protocol->send.headerAckReceived == SyncProtocol_Ack_headerOk)
        {
            SYNCPROTOCOL_DEBUG(QString("SyncProtocol_processOutgoing [%1]: Ack OK received :").arg((uint64)protocol, 0, 16));
            protocol->send.state = header->length == 0 ? SyncProtocol_SendState_readyForSend : SyncProtocol_SendState_sendingPayloadStartByte;
        }
        else if (
            (protocol->send.headerAckReceived == SyncProtocol_Ack_busy)
            || (protocol->send.headerAckReceived == SyncProtocol_Ack_portClosed))
        {
            /* Cancel payload send */
            SYNCPROTOCOL_DEBUG(QString("SyncProtocol_processOutgoing [%1]: Ack %2 received, aborting :").arg((uint64)protocol, 0, 16).arg(protocol->send.headerAckReceived));
            protocol->send.state                                = SyncProtocol_SendState_readyForSend;
            protocol->send.currentClient->send.messageValid     = FALSE;
            protocol->send.currentClient->send.messageSendError = TRUE;
            protocol->send.currentClient                        = NULL;
        }
        else if (protocol->send.headerAckReceived == SyncProtocol_Ack_headerError)
        {
            /* re-send header */
            SYNCPROTOCOL_DEBUG(QString("SyncProtocol_processOutgoing [%1]: Ack ERROR received, re-sending :").arg((uint64)protocol, 0, 16));
            protocol->send.state                = SyncProtocol_SendState_sendingHeader;
            protocol->send.headerAckReceived    = SyncProtocol_Ack_none;
            protocol->send.frameHeaderByteIndex = 0;
        }
        else if (SyncProtocol_checkPendingAck(protocol))
        {
            protocol->send.ackHeaderValid     = TRUE;
            protocol->send.ackHeaderByteIndex = 0;
        }
    }
    /* If a client frame is currently beeing send, continue sending */
    else if (protocol->send.state == SyncProtocol_SendState_sendingPayloadStartByte)
    {
        sint32 writeCount;
        uint8  data = SYNCPROTOCOL_PAYLOAD_START_BYTE;
        writeCount = 1;

        writeCount = writeCount - SyncProtocol_fifoWrite(protocol->streamOut, (void*)&data, writeCount);

        if (writeCount == 1)
        {
            SYNCPROTOCOL_DEBUG(QString("SyncProtocol_processOutgoing [%1]: Payload start byte send :").arg((uint64)protocol, 0, 16));
            protocol->send.state = SyncProtocol_SendState_sendingPayload;
        }
    }
    else if (protocol->send.state == SyncProtocol_SendState_sendingPayload)
    {
        if (SyncProtocol_sendPayload(protocol))
        {
            SYNCPROTOCOL_DEBUG(QString("SyncProtocol_processOutgoing [%1]: Payload send :").arg((uint64)protocol, 0, 16));
            protocol->send.state = SyncProtocol_SendState_waitingForPayloadAck;
        }
    }
    else if (protocol->send.state == SyncProtocol_SendState_waitingForPayloadAck)
    {
        if (protocol->send.payloadAckReceived == SyncProtocol_Ack_payloadOk)
        {
            SYNCPROTOCOL_DEBUG(QString("SyncProtocol_processOutgoing [%1]: Payload ACK OK received :").arg((uint64)protocol, 0, 16));
            protocol->send.state = SyncProtocol_SendState_readyForSend;

            if ((header->flags.B.frameType == SyncProtocol_FrameType_data)
                || (header->flags.B.frameType == SyncProtocol_FrameType_dataEnd))
            {
                protocol->send.currentClient->send.messageValid = FALSE;
            }

            protocol->send.currentClient = NULL;
        }
        else if (protocol->send.payloadAckReceived == SyncProtocol_Ack_payloadError)
        {
            /* re-send payload */
            SYNCPROTOCOL_DEBUG(QString("SyncProtocol_processOutgoing [%1]: Payload ACK ERROR received, resend :").arg((uint64)protocol, 0, 16));
            protocol->send.state                                 = SyncProtocol_SendState_sendingPayloadStartByte;
            protocol->send.payloadAckReceived                    = SyncProtocol_Ack_none;
            protocol->send.currentClient->send.messageByteIndex -= protocol->send.framePayloadByteIndex;
            protocol->send.framePayloadByteIndex                 = 0;
        }
        else if (SyncProtocol_checkPendingAck(protocol))
        {
            protocol->send.ackHeaderValid     = TRUE;
            protocol->send.ackHeaderByteIndex = 0;
        }
    }
}


/*-------------------------------------------------------------------------*/
/* SyncProtocol: Client receive API                                           */
/*-------------------------------------------------------------------------*/
static void SyncProtocol_raiseAck(SyncProtocol* protocol, uint8 frameIndex, uint8 ackStatus)
{
    if (protocol->send.pendingAckStatus != SyncProtocol_Ack_none)
    {
        protocol->status.pendingAckOverflow++;
    }

    SYNCPROTOCOL_DEBUG(QString("SyncProtocol_raiseAck [%1]: pendingAckStatus=%2, pendingAckFrameIndex=%3").arg((uint64)protocol, 0, 16).arg(ackStatus).arg(frameIndex));
    protocol->send.pendingAckStatus     = ackStatus;
    protocol->send.pendingAckFrameIndex = frameIndex;
}


boolean SyncProtocol_setReadMessageBuffer(SyncProtocol_Client* client, uint8* messagePayload, uint32 size)
{
    /* FIXME Enable to change the messagePayload address when already set. Need protection so that the pointer is not changed while message is beeing received */
    if ((client->protocol != NULL) && (client->receive.messagePayload == NULL))
    {
        client->receive.messagePayload           = messagePayload;
        client->receive.messagePayloadBufferSize = size;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


boolean SyncProtocol_getReadMessageBuffer(SyncProtocol_Client* client, SyncProtocol_MessageId* id, uint8** messagePayload, uint32* payloadLength)
{
    boolean result;

    if (client->receive.messageValid)
    {
        SYNCPROTOCOL_DEBUG(QString("SyncProtocol_getReadMessageBuffer [%1]: localPort=%2").arg((uint64)client->protocol, 0, 16).arg(client->localPort));
        *messagePayload = client->receive.messagePayload;
        *id             = client->receive.messageHeader.id;
        *payloadLength  = client->receive.messageHeader.length - SYNCPROTOCOL_MESSAGE_HEADER_SIZE;
        result          = TRUE;
    }
    else
    {
        result = FALSE;
    }

    return result;
}


void SyncProtocol_releaseReadMessageBuffer(SyncProtocol_Client* client)
{
    SYNCPROTOCOL_DEBUG(QString("SyncProtocol_releaseReadMessageBuffer [%1]: localPort=%2").arg((uint64)client->protocol, 0, 16).arg(client->localPort));
    client->receive.messageValid = FALSE;
}


static void SyncProtocol_processAck(SyncProtocol* protocol, SyncProtocol_FrameHeader* header)
{
    if (protocol->send.header.flags.B.index != SYNCPROTOCOL_FRAME_INDEX_INVALID)
    {
        if (protocol->send.header.flags.B.index == header->flags.B.indexAck)
        {
            if (protocol->send.state == SyncProtocol_SendState_waitingForHeaderAck)
            {
                SYNCPROTOCOL_DEBUG(QString("SyncProtocol_processAck [%1]: ack=%2").arg((uint64)protocol, 0, 16).arg(header->flags.B.ack));
                protocol->send.headerAckReceived = header->flags.B.ack;
            }
            else if (protocol->send.state == SyncProtocol_SendState_waitingForPayloadAck)
            {
                SYNCPROTOCOL_DEBUG(QString("SyncProtocol_processAck [%1]: ack=%2").arg((uint64)protocol, 0, 16).arg(header->flags.B.ack));
                protocol->send.payloadAckReceived = header->flags.B.ack;
            }
        }
        else
        {
            protocol->status.invalidAckFrameIndex++;
        }
    }
}


static void SyncProtocol_readHeader(SyncProtocol* protocol)
{
    ASSERT(protocol->receive.state == SyncProtocol_ReceiveState_waitingForHeader);
    sint32                    readCount = 1;
    SyncProtocol_FrameHeader* header    = &protocol->receive.header;

    while ((readCount == 1) && protocol->receive.frameHeaderByteIndex == 0)
    {
        readCount = readCount - SyncProtocol_fifoRead(protocol->streamIn, &header->startByte, readCount);

        if ((readCount == 1) && (header->startByte == SYNCPROTOCOL_HEADER_START_BYTE))
        {
            SYNCPROTOCOL_DEBUG(QString("SyncProtocol_readHeader [%1]: Header start byte received :").arg((uint64)protocol, 0, 16));
            protocol->receive.frameHeaderByteIndex = 1;
        }
    }

    /* Read the full header */
    if (protocol->receive.frameHeaderByteIndex > 0)
    {
        readCount                               = SYNCPROTOCOL_FRAME_HEADER_SIZE - protocol->receive.frameHeaderByteIndex;
        readCount                               = readCount - SyncProtocol_fifoRead(protocol->streamIn, (void*)&((uint8*)header)[protocol->receive.frameHeaderByteIndex], readCount);
        protocol->receive.frameHeaderByteIndex += readCount;

        /* Check the header */
        if (protocol->receive.frameHeaderByteIndex == SYNCPROTOCOL_FRAME_HEADER_SIZE)
        {
            if (header->checksumHeader == SyncProtocol_calculateFrameHeaderChecksum(header))
            {
                protocol->receive.deadline            = SYNCPROTOCOL_CURRENT_TIME + protocol->timeout;
                SYNCPROTOCOL_DEBUG(QString("SyncProtocol_readHeader [%1]: Header received : frameIndex=%2, sender=%3, receiver=%4").arg((uint64)protocol, 0, 16).arg(header->flags.B.index).arg(header->sender).arg(header->receiver));
                protocol->synchronized                = TRUE;
                protocol->receive.lastValidFrameIndex = header->flags.B.index;
                SyncProtocol_Client* client = protocol->clients[header->receiver];

                if ((header->receiver > SYNCPROTOCOL_PORT_MAX) || (client == NULL)
                    || (header->length > SYNCPROTOCOL_FRAME_PAYLOAD_MAX_LENGTH)
                    || (((header->flags.B.frameType == SyncProtocol_FrameType_data) || (header->flags.B.frameType == SyncProtocol_FrameType_dataStart)) && (header->length - SYNCPROTOCOL_MESSAGE_HEADER_SIZE > client->receive.messagePayloadBufferSize))
                    || (((header->flags.B.frameType == SyncProtocol_FrameType_dataMiddle) || (header->flags.B.frameType == SyncProtocol_FrameType_dataEnd)) && (header->length > client->receive.messagePayloadBufferSize))
                    )
                {
                    /* Message buffer is locked for read, or buffer lenght too small. Send port closed ACK and discard message */
                    SyncProtocol_raiseAck(protocol, header->flags.B.index, SyncProtocol_Ack_portClosed);
                    protocol->status.portClosed++;
                    protocol->receive.frameHeaderByteIndex = 0;
                }
                else if (client->remotePort != header->sender)
                {
                    /* Message sender / receiver does not match. Send port closed ACK and discard message */
                    SyncProtocol_raiseAck(protocol, header->flags.B.index, SyncProtocol_Ack_portClosed);
                    protocol->status.portClosed++;
                    protocol->receive.frameHeaderByteIndex = 0;
                }
                else if (client->receive.messageValid)
                {
                    /* Message buffer is validbut not read. Send busy ACK and discard message */
                    SyncProtocol_raiseAck(protocol, header->flags.B.index, SyncProtocol_Ack_busy);
                    protocol->status.portBusy++;
                    protocol->receive.frameHeaderByteIndex = 0;
                }
                else
                {
                    /* Prepare for payload read */

                    switch (header->flags.B.frameType)
                    {
                    case SyncProtocol_FrameType_data:
                    case SyncProtocol_FrameType_dataStart:
                        protocol->receive.payloadHeader = *header;

                        if (header->length > 0)
                        {
                            SyncProtocol_raiseAck(protocol, header->flags.B.index, SyncProtocol_Ack_headerOk);
                            client->receive.messageValid            = FALSE;
                            client->receive.messageByteIndex        = 0;

                            protocol->receive.framePayloadByteIndex = 0;
                            protocol->receive.state                 = SyncProtocol_ReceiveState_waitingForPayload;
                        }
                        else
                        {
                            SyncProtocol_raiseAck(protocol, header->flags.B.index, SyncProtocol_Ack_headerOk);
                            protocol->receive.frameHeaderByteIndex = 0;
                        }

                        break;
                    case SyncProtocol_FrameType_dataMiddle:
                    case SyncProtocol_FrameType_dataEnd:
                        protocol->receive.payloadHeader = *header;

                        if (header->length > 0)
                        {
                            if (client->receive.messageHeader.length > client->receive.messagePayloadBufferSize)
                            {   /* FIXME return dedicated ACK: Message to big for buffer */
                                SyncProtocol_raiseAck(protocol, header->flags.B.index, SyncProtocol_Ack_busy);
                                protocol->status.portBusy++;
                                protocol->receive.frameHeaderByteIndex = 0;
                            }
                            else
                            {
                                SyncProtocol_raiseAck(protocol, header->flags.B.index, SyncProtocol_Ack_headerOk);
                                protocol->receive.framePayloadByteIndex = 0;
                                protocol->receive.state                 = SyncProtocol_ReceiveState_waitingForPayload;
                            }
                        }
                        else
                        {
                            SyncProtocol_raiseAck(protocol, header->flags.B.index, SyncProtocol_Ack_headerOk);
                            protocol->receive.frameHeaderByteIndex = 0;
                        }

                        break;
                    case SyncProtocol_FrameType_ack:

                        if (protocol->waitingForPayload)
                        {
                            /* An ACk have been received while a frame was in receive process, continue receiving the frame */
                            ASSERT(protocol->receive.framePayloadByteIndex == 0);
                            protocol->waitingForPayload = FALSE;
                            protocol->receive.state     = SyncProtocol_ReceiveState_waitingForPayload;
                        }
                        else
                        {
                            protocol->receive.frameHeaderByteIndex = 0;
                        }

                        break;
                    }
                }

                SyncProtocol_processAck(protocol, header);
            }
            else
            {
                /* Invalid header */

                if (protocol->synchronized)
                {
                    SYNCPROTOCOL_DEBUG(QString("SyncProtocol_readHeader [%1]: Invalid header received while synchronized : lastValidFrameIndex=%2").arg((uint64)protocol, 0, 16).arg(protocol->receive.lastValidFrameIndex));
                    protocol->status.invalidHeader++;
                    SyncProtocol_raiseAck(protocol, SyncProtocol_getNextIndex(protocol->receive.lastValidFrameIndex), SyncProtocol_Ack_headerError);
                    protocol->synchronized = FALSE;
                }

                /* search for a new start byte in the header */
                {
                    uint8* src = (uint8*)&header;
                    uint8* dst;
                    uint8  index;
                    /* Discard the current start byte */
                    dst                                    = src;
                    index                                  = 1;
                    protocol->receive.frameHeaderByteIndex = 0;

                    while (index < SYNCPROTOCOL_FRAME_HEADER_SIZE)
                    {
                        if (src[index] == SYNCPROTOCOL_HEADER_START_BYTE)
                        {
                            protocol->receive.frameHeaderByteIndex++;
                            index++;

                            /* Copy header */
                            while (index < SYNCPROTOCOL_FRAME_HEADER_SIZE)
                            {
                                dst[protocol->receive.frameHeaderByteIndex++] = src[index++];
                            }
                        }
                        else
                        {
                            index++;
                        }
                    }
                }
            }
        }
    }
}


static void SyncProtocol_processIncomming(SyncProtocol* protocol)
{
    /* Look for header */
    if (protocol->receive.state == SyncProtocol_ReceiveState_waitingForHeader)
    {
        SyncProtocol_readHeader(protocol);
    }
    else if (protocol->receive.deadline <= SYNCPROTOCOL_CURRENT_TIME)
    {
        protocol->status.receiveTimeout++;
        protocol->receive.frameHeaderByteIndex = 0;
        protocol->waitingForPayload            = FALSE;
        protocol->receive.state                = SyncProtocol_ReceiveState_waitingForHeader;
        SYNCPROTOCOL_DEBUG(QString("SyncProtocol_processIncomming [%1]: Receive timeout").arg((uint64)protocol, 0, 16));
    }
    /* Check if the next data is ack header or payload */
    else if (protocol->receive.state == SyncProtocol_ReceiveState_waitingForPayload)
    {
        sint32 readCount;
        readCount = 1;
        uint8 data = 0;
        readCount = readCount - SyncProtocol_fifoRead(protocol->streamIn, &data, readCount);

        if (readCount == 1)
        {
            if (data == SYNCPROTOCOL_HEADER_START_BYTE)
            {
                SYNCPROTOCOL_DEBUG(QString("SyncProtocol_processIncomming [%1]: Header start byte received").arg((uint64)protocol, 0, 16));
                protocol->receive.header.startByte     = SYNCPROTOCOL_HEADER_START_BYTE;
                protocol->receive.frameHeaderByteIndex = 1;
                protocol->receive.state                = SyncProtocol_ReceiveState_waitingForHeader;
                protocol->waitingForPayload            = TRUE;
            }
            else if (data == SYNCPROTOCOL_PAYLOAD_START_BYTE)
            {
                SYNCPROTOCOL_DEBUG(QString("SyncProtocol_processIncomming [%1]: Payload start byte received").arg((uint64)protocol, 0, 16));
                protocol->receive.state = SyncProtocol_ReceiveState_readingPayload;
            }
            else
            {
                protocol->status.invalidStartByte++;
                protocol->receive.frameHeaderByteIndex = 0;
                protocol->waitingForPayload            = FALSE;
                protocol->receive.state                = SyncProtocol_ReceiveState_waitingForHeader;
            }
        }
    }
    /* Read payload */
    else if (protocol->receive.state == SyncProtocol_ReceiveState_readingPayload)
    {
        sint32                    readCount;
        SyncProtocol_FrameHeader* header = &protocol->receive.payloadHeader;
        SyncProtocol_Client*      client = protocol->clients[header->receiver];

        ASSERT(header->length > 0);
        /* Read message header */
        readCount = SYNCPROTOCOL_MESSAGE_HEADER_SIZE - client->receive.messageByteIndex;

        if (readCount > 0)
        {
            readCount                                = readCount - SyncProtocol_fifoRead(protocol->streamIn, (void*)&((uint8*)&client->receive.messageHeader)[client->receive.messageByteIndex], readCount);
            protocol->receive.framePayloadByteIndex += readCount;
            client->receive.messageByteIndex        += readCount;
        }

        if (client->receive.messageByteIndex >= SYNCPROTOCOL_MESSAGE_HEADER_SIZE)
        {
            /* Read message payload */
            readCount = header->length - protocol->receive.framePayloadByteIndex;

            if (readCount > 0)
            {
                readCount                                = readCount - SyncProtocol_fifoRead(protocol->streamIn, (void*)&client->receive.messagePayload[client->receive.messageByteIndex - SYNCPROTOCOL_MESSAGE_HEADER_SIZE], readCount);
                protocol->receive.framePayloadByteIndex += readCount;
                client->receive.messageByteIndex        += readCount;
            }
        }

        if (protocol->receive.framePayloadByteIndex == header->length)
        {
            uint8 checksum;

            if (client->receive.messageByteIndex - header->length == 0)
            {
                checksum = SyncProtocol_calculateFramePayloadChecksum(
                    header,
                    &client->receive.messageHeader,
                    &client->receive.messagePayload[0]);
            }
            else
            {
                checksum = SyncProtocol_calculateFramePayloadChecksum(
                    header,
                    NULL,
                    &client->receive.messagePayload[client->receive.messageByteIndex - SYNCPROTOCOL_MESSAGE_HEADER_SIZE - header->length]);
            }

            if (header->checksumPayload == checksum)
            {
                SYNCPROTOCOL_DEBUG(QString("SyncProtocol_processIncomming [%1]: Payload received").arg((uint64)protocol, 0, 16));
                SyncProtocol_raiseAck(protocol, header->flags.B.index, SyncProtocol_Ack_payloadOk);

                if (client->receive.messageByteIndex == client->receive.messageHeader.length)
                {
                    SYNCPROTOCOL_DEBUG(QString("SyncProtocol_processIncomming [%1]: Message received, ID=0x%2").arg((uint64)protocol, 0, 16).arg(client->receive.messageHeader.id, 0, 16));
                    client->receive.messageValid = TRUE;
                }

                protocol->receive.frameHeaderByteIndex = 0;
                protocol->waitingForPayload            = FALSE;
                protocol->receive.state                = SyncProtocol_ReceiveState_waitingForHeader;
            }
            else
            {
                SYNCPROTOCOL_DEBUG(QString("SyncProtocol_processIncomming [%1]: Payload received (checksum error)").arg((uint64)protocol, 0, 16));
                SyncProtocol_raiseAck(protocol, header->flags.B.index, SyncProtocol_Ack_payloadError);
                client->receive.messageByteIndex       -= protocol->receive.framePayloadByteIndex;
                protocol->receive.framePayloadByteIndex = 0;
                protocol->receive.state                 = SyncProtocol_ReceiveState_waitingForPayload;
                protocol->status.payloadError++;
            }
        }
    }
}
